<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogReel Pro</title>
    <style>
        :root {
            --primary-color-rgb: 59, 130, 246; /* Tailwind Blue 500 */
            --primary-color: rgb(var(--primary-color-rgb));
            --primary-color-dark: #2563EB; /* Tailwind Blue 600 */
            --secondary-color: #50E3C2; /* A contrasting teal/mint - kept from original */
            --text-color: #1F2937; /* Tailwind Gray 800 */
            --text-color-light: #4B5563; /* Tailwind Gray 600 */
            --text-color-very-light: #6B7280; /* Tailwind Gray 500 */
            --bg-color: #F9FAFB; /* Tailwind Gray 50 */
            --card-bg-color: #FFFFFF;
            --border-color: #E5E7EB; /* Tailwind Gray 200 */
            --input-border-color: #D1D5DB; /* Tailwind Gray 300 */
            --danger-color: #EF4444; /* Tailwind Red 500 */
            --danger-color-dark: #DC2626; /* Tailwind Red 600 */
            --warning-color: #F59E0B; /* Tailwind Amber 500 */
            --success-color: #10B981; /* Tailwind Emerald 500 */
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            
            --border-radius-small: 4px;
            --border-radius: 8px; /* Slightly larger default radius */
            --border-radius-large: 12px;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.06), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -4px rgba(0, 0, 0, 0.07);
            --shadow-xl: 0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1);

            --input-focus-ring: 0 0 0 3px rgba(var(--primary-color-rgb), 0.25);
            --transition-fast: all 0.15s ease-in-out;
            --transition-base: all 0.25s ease-in-out;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: var(--transition-base); /* For potential future dark mode */
        }
        
        /* Screen transition */
        .screen { 
            display: none; 
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .screen.active { 
            display: block; 
            opacity: 1;
        }


        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Headers */
        .app-header {
            background-color: var(--card-bg-color);
            color: var(--text-color);
            padding: 20px 24px;
            text-align: center;
            margin-bottom: 32px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }
        .app-header h1 {
            font-size: 2em; /* Increased size */
            font-weight: 700; /* Bolder */
            letter-spacing: -0.025em; /* Tighter letter spacing */
        }

        .header-with-back {
            display: grid;
            grid-template-columns: auto 1fr auto; 
            align-items: center;
            background-color: var(--card-bg-color);
            color: var(--text-color);
            padding: 16px 24px;
            margin-bottom: 32px;
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 900;
        }
       
        .header-left-actions {
            grid-column: 1 / 2; /* Position this group in the first column */
            display: flex;
            align-items: center;
            gap: 4px; /* Adjust gap between back and home buttons as needed */
        }

        .header-icon-button { /* Generic style for header icon buttons like back, home */
            background: none;
            border: none;
            color: var(--text-color-light);
            font-size: 1em; /* SVG will control size */
            cursor: pointer;
            padding: 8px;
            border-radius: var(--border-radius-small);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            line-height: 1; /* Ensure consistent height */
        }
        .header-icon-button:hover {
            color: var(--primary-color);
            background-color: rgba(var(--primary-color-rgb), 0.1);
        }
        .header-icon-button svg {
            width: 24px;
            height: 24px;
        }


        .header-with-back h2 {
            grid-column: 2 / 3;
            font-size: 1.5em; /* Increased */
            font-weight: 600;
            margin: 0;
            text-align: center;
            letter-spacing: -0.01em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        .header-spacer-right {
            grid-column: 3 / 4;
            min-width: 40px; /* Base width for spacer, will be overridden by JS */
            visibility: hidden; 
        }


        /* Buttons */
        .button {
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            gap: 8px; /* Space between icon and text */
            padding: 10px 20px;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            transition: var(--transition-base);
            white-space: nowrap;
        }
        .button:focus-visible {
            outline: none;
            box-shadow: var(--input-focus-ring);
        }
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: var(--border-color) !important;
            color: var(--text-color-light) !important;
            border-color: var(--border-color) !important;
            box-shadow: none !important;
        }
        .button:disabled .button-icon svg { color: var(--text-color-light) !important; }

        .button-primary {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        .button-primary:hover:not(:disabled) {
            background-color: var(--primary-color-dark);
            border-color: var(--primary-color-dark);
            box-shadow: var(--shadow-md);
        }
        .button-secondary {
            background-color: var(--card-bg-color);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .button-secondary:hover:not(:disabled) {
            background-color: rgba(var(--primary-color-rgb), 0.05); /* Lighter primary tint */
            border-color: var(--primary-color-dark);
            color: var(--primary-color-dark);
        }
        .button-danger {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
        }
        .button-danger:hover:not(:disabled) {
            background-color: var(--danger-color-dark);
            border-color: var(--danger-color-dark);
            box-shadow: var(--shadow-md);
        }
        .button-subtle {
            background-color: transparent;
            color: var(--text-color-light);
            border-color: var(--border-color);
        }
        .button-subtle:hover:not(:disabled) {
            background-color: #F3F4F6; /* Tailwind Gray 100 */
            color: var(--text-color);
            border-color: #D1D5DB; /* Tailwind Gray 300 */
        }
        .button-full-width { display: flex; width: 100%; margin-bottom: 12px; }
        .button-small { padding: 8px 12px; font-size: 0.875em; gap: 6px;}
        .button .button-icon { display: inline-flex; align-items: center; justify-content: center; }
        .button .button-icon svg { width: 18px; height: 18px; } /* Default icon size */
        .button-small .button-icon svg { width: 16px; height: 16px; }
        .button .button-icon-only { margin-right: 0; } 


        /* Cards */
        article.card, article.video-entry-card, article.log-item {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-large); /* Larger radius for cards */
            margin-bottom: 24px; 
            box-shadow: var(--shadow-md);
            transition: box-shadow var(--transition-fast);
        }
        article.card:hover, article.video-entry-card:hover {
            box-shadow: var(--shadow-lg);
        }
        article.video-entry-card { padding: 0; margin-bottom: 32px; }
        article.log-item { padding: 20px; } 

        .card-title { 
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-color);
        }
        .card-meta {
            font-size: 0.9em;
            color: var(--text-color-light);
            margin-bottom: 16px;
        }
        .card-actions {
            margin-top: 24px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        article.card .card-actions, article.log-item .card-actions { 
             padding: 0 24px 24px; /* Consistent padding */
             margin-top: 16px; 
        }
        
        .card-actions .button { flex-grow: 1; }
        @media (max-width: 480px) {
            .card-actions .button { min-width: 100%; }
        }


        /* Forms */
        .form-group { margin-bottom: 24px; }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.9em;
            color: var(--text-color-light);
        }
        .form-group input[type="text"],
        .form-group input[type="search"],
        .form-group textarea,
        .form-group select /* Added select */ {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--input-border-color);
            border-radius: var(--border-radius);
            font-size: 1em;
            font-family: var(--font-family);
            background-color: var(--card-bg-color);
            color: var(--text-color);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }
        .form-group input[type="text"]:focus,
        .form-group input[type="search"]:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            border-color: var(--primary-color);
            /*box-shadow: var(--input-focus-ring);*/
            outline: none;
        }
        .form-group textarea { min-height: 120px; resize: vertical; }
        input[type="search"] {
            padding: 12px 16px;
            font-size: 1em;
            border: 1px solid var(--input-border-color);
            border-radius: var(--border-radius);
            width: 100%;
            margin-bottom: 24px;
        }
        input[type="search"]:focus {
            border-color: var(--primary-color);
            box-shadow: var(--input-focus-ring);
            outline: none;
        }
         /* Select specific styling for arrow */
        .form-group select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25em 1.25em;
            padding-right: 2.5rem; /* Make space for arrow */
        }
        /* Style for video controls select */
         .video-controls .speed-control-group select.button { /* Remove button class here, or override */
             padding: 10px 16px; /* Adjust if needed */
             padding-right: 2.5rem; /* Ensure space for custom arrow if keeping button class styling */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
             background-repeat: no-repeat;
             background-position: right 0.75rem center;
             background-size: 1.25em 1.25em;
             appearance: none;
         }


        /* Modals */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(17, 24, 39, 0.6); /* Tailwind Gray 900 with opacity */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            opacity: 0; transition: opacity var(--transition-base);
        }
        .modal.visible { opacity: 1; }
        .modal-content {
            background-color: var(--card-bg-color); margin: 8% auto; padding: 28px;
            border-radius: var(--border-radius-large); width: 90%; max-width: 550px;
            box-shadow: var(--shadow-xl); 
            transform: scale(0.95);
            transition: transform var(--transition-base);
        }
        .modal.visible .modal-content { transform: scale(1); }
        
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: 16px; border-bottom: 1px solid var(--border-color); margin-bottom: 24px;
        }
        .modal-title { font-size: 1.5em; font-weight: 600; }
        .close-button {
            color: var(--text-color-very-light); font-size: 1em; /* SVG will control size */
            cursor: pointer; background: none; border: none; padding: 8px; line-height: 1;
            border-radius: var(--border-radius-small);
            transition: var(--transition-fast);
            display: inline-flex; align-items: center; justify-content: center;
        }
        .close-button:hover { color: var(--text-color); background-color: rgba(0,0,0,0.05); }
        .close-button svg { width: 24px; height: 24px; }

        /* Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: calc(100% - 48px); 
        }
        .toast-message {
            display: flex; /* For icon alignment */
            align-items: center;
            gap: 10px; /* Space between icon and text */
            padding: 14px 20px;
            background-color: var(--text-color);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            font-size: 0.95em;
            opacity: 0;
            transform: translateX(110%); 
            transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .toast-message svg { width: 20px; height: 20px; flex-shrink: 0; }
        .toast-message.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-message.error { background-color: var(--danger-color); }
        .toast-message.success { background-color: var(--success-color); }
        .toast-message.warning { background-color: var(--warning-color); color: var(--text-color); }
        .toast-message.info { background-color: var(--primary-color); }


        /* General UI Elements */
        .actions-bar {
            margin-bottom: 90px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .actions-bar .button { flex: 1; min-width: calc(50% - 8px); }
        @media (max-width: 480px) { .actions-bar .button { min-width: 100%; } }

        .section-title {
            font-size: 1.3em; font-weight: 600; margin-top: 32px;
            margin-bottom: 16px; padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color); color: var(--text-color);
        }
        .empty-state {
            text-align: center; padding: 48px 24px;
            color: var(--text-color-light); border: 2px dashed var(--border-color);
            border-radius: var(--border-radius-large); margin-top: 24px;
            background-color: #F9FAFB; /* Slightly off-white */
        }
        .empty-state .empty-state-icon { margin-bottom: 16px; }
        .empty-state .empty-state-icon svg { width: 48px; height: 48px; color: var(--text-color-very-light); opacity: 0.7; }
        .empty-state p { font-size: 1.1em; margin-bottom: 16px; }


        /* Screen 2: Project Videos - Layout */
        .video-entry-header {
            padding: 18px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            gap: 16px; 
            margin-bottom: 0; /* Handled by player or clips list */
        }
        .video-entry-title {
            font-size: 1.2em; /* Increased */
            font-weight: 600;
            color: var(--text-color);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
            flex-grow: 1;
        }
        .video-card-number {
            font-weight: 500; /* Medium weight */
            color: var(--text-color-light);
            margin-right: 6px;
        }
        .video-entry-actions {
            display: flex;
            align-items: center;
            gap: 10px; 
            flex-shrink: 0;
        }
        .video-entry-actions .button { margin-left: 0; }
        .btn-toggle-important .button-icon svg { width: 20px; height: 20px; }
        .btn-toggle-important.is-important .button-icon svg { color: var(--warning-color); }

        /* Consolidated Player Area on Card - Screen 2 */
        .main-video-preview-area {
            padding: 0; 
            background-color: #000; 
            position: relative;
            min-height: 180px; /* Increased min height */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; 
            border-bottom-left-radius: var(--border-radius-large); /* To match card */
            border-bottom-right-radius: var(--border-radius-large);
        }
        .main-video-thumbnail {
            width: 100%; 
            height: auto;
            max-height: 350px; /* Increased max height */
            object-fit: contain; 
            cursor: pointer;
            display: block; 
        }
         .main-video-thumbnail.hidden { display: none; }

        .play-main-video-preview-btn { 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 50%;
            width: 80px; 
            height: 80px;
            padding: 0;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 10; 
            box-shadow: var(--shadow-lg);
        }
        .play-main-video-preview-btn svg { width: 40px; height: 40px; } /* SVG size for play-circle */
        .play-main-video-preview-btn:hover { background: rgba(0,0,0,0.7); transform: translate(-50%, -50%) scale(1.05); }
        .play-main-video-preview-btn.hidden { display: none; }

        .main-video-preview-player { 
            width: 100%;
            display: block;
            max-height: 350px; 
            background-color: #000;
        }
        .main-video-preview-player.hidden { display: none; }

        /* Custom Controls for Main Player on Card - Screen 2 (MODIFIED TO BE OVER VIDEO) */
        .main-player-custom-controls {
            position: absolute; bottom: 0; left: 0; width: 100%; z-index: 20;
            display: flex;
            align-items: center;
            gap: 8px; 
            padding: 12px 16px; 
            background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.4) 60%, rgba(0,0,0,0) 100%);
            color: white; 
            opacity: 0; /* Hidden by default */
            visibility: hidden; /* Hidden by default */
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .main-player-custom-controls.visible { 
            opacity: 1; 
            visibility: visible;
        }
        
        .main-player-ctrl-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5); 
            font-size: 1em; /* SVG will control size */
            padding: 8px; 
            cursor: pointer;
            line-height: 1;
            border-radius: var(--border-radius-small);
            transition: background-color var(--transition-fast);
        }
        .main-player-ctrl-btn:hover { background-color: rgba(255,255,255,0.2); }
        .main-player-ctrl-btn svg { width: 20px; height: 20px; }

        .main-player-progress-bar-container {
            flex-grow: 1;
            height: 6px; /* Slimmer */
            background-color: rgba(255,255,255,0.15);
            border-radius: 3px;
            cursor: pointer;
            margin: 0 8px;
            position: relative; 
        }
        .main-player-progress-bar {
            height: 100%;
            background-color: rgba(59, 130, 246, 0.5);
            border-radius: 3px;
            width: 0%;
        }
        .main-player-timecode {
            font-size: 0.85em;
            color: color: rgba(255, 255, 255, 0.4); 
            font-family: monospace;
            min-width: 90px; 
            text-align: right;
            padding-left: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .main-player-custom-controls .main-player-speed-control-group {
            display: flex;
            align-items: center;
            margin: 0 8px; /* Adjust spacing as needed */
        }

        .main-player-custom-controls .main-player-speed-select {
            background-color: rgba(255,255,255,0.05); /* Lighten background slightly for better visibility */
            color: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: var(--border-radius-small);
            padding: 4px 24px 4px 8px; /* More padding-right for arrow */
            font-size: 0.8em;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='rgba(255,255,255,0.5)' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 6px center;
            background-size: 1em 1em;
            min-width: 65px; /* Ensure it doesn't get too narrow */
            height: 30px; /* Match other control button touch area better */
            line-height: 1.5; /* Align text vertically if needed */
        }

        .main-player-custom-controls .main-player-speed-select:focus {
            outline: none;
            /*border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.5);*/
        }

        .main-player-custom-controls .main-player-speed-select option {
            background-color: var(--text-color); /* Dark background for dropdown */
            color: white;
        }


        .main-video-preview-prompt { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background-color: rgba(0,0,0,0.9); color: white; padding: 24px; text-align: center;
            z-index: 30; 
        }
        .main-video-preview-prompt.hidden { display: none; }
        .main-video-preview-prompt p { margin-bottom: 16px; font-size: 1em; line-height: 1.5; }


        /* Scrollable Logged Clips List - Screen 2 */
        .video-clips-list-container {
            padding: 20px 24px; 
            min-height: 460px;
            max-height: 460px;
            overflow-y: auto;
            scroll-behavior: smooth;
            background-color: #F9FAFB; /* Light bg for clip list section */
        }
        .video-clips-list-container h4 { 
            font-size: 1.1em; font-weight: 600; color: var(--text-color);
            margin-bottom: 16px; 
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color); 
        }
        .clip-item-card {
            display: flex;
            gap: 16px;
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 16px;
            background-color: var(--card-bg-color);
            align-items: center;
            transition: var(--transition-fast);
        }
        .clip-item-card:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-sm);
        }
        .clip-item-card:last-child { margin-bottom: 0; }
        .clip-item-thumbnail {
            width: 100px; height: 60px; /* Larger */
            background-color: var(--border-color); object-fit: cover;
            border-radius: var(--border-radius-small); flex-shrink: 0;
        }
        .clip-item-info { flex-grow: 1; min-width:0; }
        .clip-item-info .notes { font-size: 1em; margin-bottom: 6px; font-weight: 500; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .clip-item-info .time, .clip-item-info .keywords, .clip-item-info .rating-display {
            font-size: 0.85em; color: var(--text-color-light); margin-bottom: 4px;
        }
        .clip-item-info .rating-display .star-icon { width: 14px; height: 14px; margin-right: 2px; vertical-align: text-bottom; }
        .clip-item-info .rating-display .star-icon.filled { color: var(--warning-color); }
        .clip-item-info .rating-display .star-icon.empty { color: var(--border-color); }

        .clip-item-actions { display: flex; flex-direction: column; gap: 8px; align-items: flex-end; flex-shrink:0; }
        .clip-item-actions .button-small { padding: 6px 10px; font-size: 0.8em; }

        /* Screen 3: Video Logging */
        #video-player-container {
            width: 100%; background-color: black; margin-bottom: 16px;
            position: relative; border-radius: var(--border-radius); overflow:hidden;
            box-shadow: var(--shadow-lg);
        }
        #video-player { width: 100%; display: block; max-height: 60vh; /* Increased max height */ }
        #video-file-prompt {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.9); color: white; padding: 28px; text-align: center;
            border-radius: var(--border-radius); z-index:10;
        }
        #video-file-prompt p { margin-bottom: 16px; line-height: 1.5; font-size: 1em;}
        #video-file-prompt strong { color: var(--secondary-color); }
        
        .video-controls { 
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            padding: 14px 18px;
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }
        .video-controls .main-controls { display: flex; align-items: center; gap: 10px; }
        .video-controls .button .button-icon svg { width: 22px; height: 22px; } /* Larger icons for main controls */
        .video-controls .timecode-display { font-family: monospace; font-size: 1em; color: var(--text-color); text-align: center; flex-grow: 1; min-width: 140px; }
        .video-controls .speed-control-group { display: flex; align-items: center; }
        .video-controls .speed-control-group select { min-width: 50px; text-align: center; text-align-last: center; } /* Handled by global form style now */
        
        #timeline-container {
            width: 100%; height: 10px; background-color: #E5E7EB; /* Lighter gray */ cursor: pointer;
            border-radius: 5px; margin-bottom: 10px; overflow: hidden;
            touch-action: pan-y;
        }
        #timeline-progress { height: 100%; background-color: var(--primary-color); border-radius: 5px; }
        .mark-buttons { display: flex; gap: 16px; margin-bottom: 24px; }
        .mark-buttons .button { flex-grow: 1; }
        .mark-buttons .button.active-mark { background-color: var(--primary-color); color: white; }
        
        .star-rating { display: flex; gap: 8px; /*cursor: pointer;*/ margin-bottom: 16px; -webkit-tap-highlight-color: transparent; }
        .star-rating .star { background: none; border: none; padding: 0; font-size: 1em; /* SVG will control */ color: var(--border-color); line-height: 1; cursor: pointer; transition: color var(--transition-fast), transform var(--transition-fast); }
        .star-rating .star svg { width: 32px; height: 32px; } /* Larger stars */
        .star-rating .star.selected svg, .star-rating .star:hover svg { color: var(--warning-color); }
        .star-rating .star:hover svg { transform: scale(1.1); }
        .star-rating .star:focus-visible { outline: 2px solid var(--primary-color); outline-offset: 2px; border-radius: var(--border-radius-small); }
        
        /* Tag Input for Keywords */
        .tag-input-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            padding: 8px 10px;
            border: 1px solid var(--input-border-color);
            border-radius: var(--border-radius);
            background-color: var(--card-bg-color);
            min-height: 46px; /* Match input height */
        }

        /*
        .tag-input-container:focus-within {
            border-color: var(--primary-color);
            box-shadow: var(--input-focus-ring);
        }
        */
        .tag-input-container .tag-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background-color: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: var(--border-radius-small);
            font-size: 0.85em;
        }
        .tag-input-container .tag-item .remove-tag-btn {
            background: none; border: none; color: white; cursor: pointer; padding: 0; margin-left: 2px;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .tag-input-container .tag-item .remove-tag-btn svg { width: 14px; height: 14px; }
        .tag-input-container #log-keywords-input-field {
            flex-grow: 1;
            border: none;
            outline: none;
            padding: 4px 0; /* Minimal padding */
            font-size: 1em;
            background-color: transparent;
            min-width: 150px; /* Minimum width before wrapping */
        }

        .tag-input-container #log-keywords-input-field:focus {
            box-shadow: none;
        }

        .log-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .log-item-time { font-weight: 600; font-size: 1em; }
        .log-item-notes { margin-bottom: 10px; font-size:1em; color: var(--text-color-light); }
        .log-item-keywords { font-style: italic; font-size: 0.9em; color: var(--text-color-very-light); margin-bottom: 10px; }
        .log-item-keywords span { /* Small tag like display for keywords in list */
            display: inline-block;
            background-color: #F3F4F6; /* Tailwind Gray 100 */
            color: var(--text-color-light);
            padding: 2px 6px;
            border-radius: var(--border-radius-small);
            margin-right: 4px;
            margin-bottom: 4px;
            font-size: 0.9em;
            font-style: normal;
        }
        .log-item-rating-display .star-icon { width: 16px; height: 16px; margin-right: 2px; } /* Consistency */
        .log-item img { max-width:120px; max-height:70px; border-radius:var(--border-radius-small); margin-top:10px; border:1px solid var(--border-color); }

        .file-input-label {
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
            padding: 10px 20px; font-size: 0.95em; font-weight: 500;
            cursor: pointer; text-align: center; text-decoration: none;
            border: 1px solid var(--primary-color); border-radius: var(--border-radius);
            background-color: var(--primary-color); color: white;
            transition: var(--transition-base);
        }
        .file-input-label:hover { background-color: var(--primary-color-dark); border-color: var(--primary-color-dark); }
        .file-input-label .button-icon svg { width: 18px; height: 18px; }
        input[type="file"] { display: none; }
        
        .hidden { display: none !important; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }

        .mt-1 { margin-top: 10px; }
        .mb-1 { margin-bottom: 10px; }

        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }


        @media (max-width: 600px) {
            .container { padding: 16px; }
            .app-header h1 { font-size: 1.6em; }
            .header-with-back h2 { font-size: 1.25em; }
            /* .header-with-back .back-button { margin-right: 8px; } */ /* Removed for new structure */
            .header-spacer-right { min-width: 30px; }

            .video-controls { flex-direction: column; align-items: stretch; }
            .video-controls .main-controls { justify-content: space-around; width: 100%; margin-bottom: 12px; } /* Space around for better tap targets */
            .video-controls .timecode-display { margin-bottom: 12px; min-width: unset; font-size: 0.9em; }
            .video-controls .speed-control-group { justify-content: center; width: 100%; }
            .video-controls .speed-control-group select { width: 100%; }

            .mark-buttons { flex-direction: column; gap: 10px; }
            
            .video-entry-header { 
                padding: 16px; 
                flex-direction: column; 
                align-items: flex-start; 
                gap: 12px; 
            }
            .video-entry-title { font-size: 1.1em; width: 100%;}
            .video-entry-actions { 
                width: 100%; 
                display: flex; 
                justify-content: flex-start; /* Align actions to start */
                gap: 8px;
                flex-wrap: wrap; /* Allow wrapping for many actions */
            }
            .video-entry-actions .button { flex-grow: 0 !important; margin-left: 0 !important; }
            
            .video-clips-list-container { padding: 16px; max-height: 350px; /* Adjusted for mobile */ }

            .clip-item-card { flex-direction: column; align-items: flex-start; gap: 12px; }
            .clip-item-thumbnail { width: 100%; height: auto; max-height: 180px; margin-bottom:10px; }
            .clip-item-actions { width: 100%; flex-direction: row; justify-content: flex-start; margin-top: 12px; gap: 8px; }
            .clip-item-actions .button-small { flex-grow: 1; }

            .main-player-custom-controls { 
                flex-wrap: wrap; 
                justify-content: center; 
                padding: 10px; 
                gap: 6px;
            }
            .main-player-progress-bar-container { 
                order: 1; 
                width: 100%; 
                margin: 10px 0 8px; 
                height: 8px; /* Slightly thicker for touch */
            } 
             .main-player-progress-bar { border-radius: 4px; }

            .main-player-custom-controls .main-player-speed-control-group {
                order: 2; /* Place it after main buttons, before timecode */
                margin-bottom: 6px; /* Add some spacing if it wraps alone */
                margin-left: 0; margin-right: 0; /* Center if it wraps */
                width: auto; /* Allow natural width or set specifically */
            }
            .main-player-timecode { 
                order: 3; 
                margin-left: 8px; /* Adjusted margin */
                font-size: 0.8em;
                 width: auto; /* Take needed space */
            }
             .main-player-custom-controls .main-player-stop-btn {
                order: 4; /* Ensure stop button is last on its own line if wrapped */
            }
            .main-player-ctrl-btn { 
                font-size: 1em; 
                padding: 6px; 
            }
            .main-player-ctrl-btn svg { width: 18px; height: 18px; }

            .modal-content { margin: 5% auto; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Screen 1: Projects List -->
        <div id="screen-projects" class="screen">
            <header class="app-header">
                <h1>LogReel Pro</h1>
            </header>
            <div class="container">
                <div class="actions-bar">
                    <button id="btn-new-project" class="button button-primary">
                        <span class="button-icon" data-icon="plus"></span> New Project
                    </button>
                    <label class="button button-secondary">
                        <span class="button-icon" data-icon="upload"></span> Import Projects
                        <input type="file" id="import-projects-input" accept=".json">
                    </label>
                </div>
                <div id="projects-list" aria-live="polite" aria-atomic="true">
                    <!-- Project cards will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Screen 2: Project Videos (NEW LAYOUT) -->
        <div id="screen-project-videos" class="screen">
            <header class="header-with-back">
                <div class="header-left-actions" id="project-videos-header-left-actions">
                    <button id="btn-back-to-projects" class="back-button header-icon-button" aria-label="Back to projects list">
                        <span data-icon="arrow-left"></span>
                    </button>
                    <button id="btn-home-from-project-videos" class="home-button header-icon-button" aria-label="Go to home screen">
                        <span data-icon="home"></span>
                    </button>
                </div>
                <h2 id="project-name-header">Project Name</h2>
                <div class="header-spacer-right" id="project-videos-header-spacer"></div>
            </header>
            <div class="container">
                <div class="actions-bar">
                    <label class="button button-primary add-videos-button-label">
                        <span class="button-icon" data-icon="plus"></span>
                        <span id="add-videos-top-text">Add Videos</span>
                        <input type="file" class="add-videos-input-actual" multiple accept="video/*" aria-labelledby="add-videos-top-text">
                    </label>
                    <button id="btn-export-project" class="button button-secondary">
                        <span class="button-icon" data-icon="download"></span> Export Project
                    </button>
                </div>
                <input type="search" id="project-videos-search" placeholder="Search videos or clips by name, notes, tags..." aria-label="Search videos and clips">
                
                <div id="project-videos-container" aria-live="polite" aria-atomic="true">
                    <!-- Video Entry Cards will be rendered here with new structure -->
                </div>
                
                <!-- New Bottom Add Videos Bar -->
                <div id="bottom-add-videos-bar" class="actions-bar hidden" style="margin-top: 32px; padding-bottom: 20px; justify-content: center;">
                    <label class="button button-primary add-videos-button-label">
                        <span class="button-icon" data-icon="plus"></span>
                        <span id="add-videos-bottom-text">Add More Videos</span>
                        <input type="file" class="add-videos-input-actual" multiple accept="video/*" aria-labelledby="add-videos-bottom-text">
                    </label>
                </div>
            </div>
        </div>

        <!-- Screen 3: Video Logging -->
        <div id="screen-video-logging" class="screen">
            <header class="header-with-back">
                 <div class="header-left-actions" id="video-logging-header-left-actions">
                    <button id="btn-back-to-project-videos" class="back-button header-icon-button" aria-label="Back to project videos">
                        <span data-icon="arrow-left"></span>
                    </button>
                    <button id="btn-home-from-video-logging" class="home-button header-icon-button" aria-label="Go to home screen">
                        <span data-icon="home"></span>
                    </button>
                </div>
                <h2 id="video-filename-header">Video Filename</h2>
                <div class="header-spacer-right" id="video-logging-header-spacer"></div>
            </header>
            <div class="container">
                <div id="video-player-container">
                    <video id="video-player" playsinline></video> 
                     <div id="video-file-prompt" class="hidden"> 
                        <p id="video-file-prompt-message">Please select the video file.</p>
                        <label class="button button-primary mt-1">
                            <span class="button-icon" data-icon="video"></span> Select Video File
                            <input type="file" id="video-file-input-logging" accept="video/*">
                        </label>
                    </div>
                </div>

                <div id="timeline-container" class="mb-1" aria-label="Video timeline"><div id="timeline-progress"></div></div>
                
                <div class="video-controls">
                    <div class="main-controls">
                        <button id="rewind-btn" class="button button-subtle" aria-label="Rewind 5 seconds">
                            <span class="button-icon" data-icon="rewind"></span> 
                        </button>
                        <button id="play-pause-btn" class="button button-subtle" aria-label="Play video">
                            <span class="button-icon" data-icon="play"></span> 
                        </button>
                        <button id="forward-btn" class="button button-subtle" aria-label="Forward 5 seconds">
                            <span class="button-icon" data-icon="forward"></span> 
                        </button>
                    </div>
                    <div id="timecode-display" class="timecode-display" aria-live="off">00:00 / 00:00</div>
                    <div class="speed-control-group">
                        <label for="speed-select" class="sr-only">Playback Speed:</label>
                        <select id="speed-select" aria-label="Playback speed" class="form-group"> <!-- No button class needed -->
                            <option value="0.5">0.5x</option>
                            <option value="0.75">0.75x</option>
                            <option value="1">1x</option>
                            <option value="1.25">1.25x</option>
                            <option value="1.5">1.5x</option>
                            <option value="2">2x</option>
                            <option value="2.5">2.5x</option>
                            <option value="3" selected>3x</option>
                        </select>
                    </div>
                </div>

                <div class="mark-buttons">
                    <button id="mark-in-btn" class="button button-secondary">
                        <span class="button-icon" data-icon="mark-in"></span> Mark In (00:00.0)
                    </button>
                    <button id="mark-out-btn" class="button button-secondary">
                        <span class="button-icon" data-icon="mark-out"></span> Mark Out (00:00.0)
                    </button>
                </div>

                <article class="card">
                    <div style="padding: 24px 24px 0;">
                        <h3 class="card-title">Log Entry</h3>
                        <div class="form-group">
                            <label for="log-notes">Notes:</label>
                            <textarea id="log-notes"></textarea>
                        </div>
                        <div class="form-group">
                            <label id="rating-label">Rating:</label>
                            <div id="log-rating" class="star-rating" role="group" aria-labelledby="rating-label">
                                <button type="button" class="star" data-value="1" aria-label="Rate 1 star" aria-pressed="false"><span data-icon="star-outline"></span></button>
                                <button type="button" class="star" data-value="2" aria-label="Rate 2 stars" aria-pressed="false"><span data-icon="star-outline"></span></button>
                                <button type="button" class="star" data-value="3" aria-label="Rate 3 stars" aria-pressed="false"><span data-icon="star-outline"></span></button>
                                <button type="button" class="star" data-value="4" aria-label="Rate 4 stars" aria-pressed="false"><span data-icon="star-outline"></span></button>
                                <button type="button" class="star" data-value="5" aria-label="Rate 5 stars" aria-pressed="false"><span data-icon="star-outline"></span></button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="log-keywords-input-field">Keywords:</label>
                            <div id="log-keywords-container" class="tag-input-container">
                                <input type="text" id="log-keywords-input-field" placeholder="Add keyword...">
                            </div>
                            <input type="hidden" id="log-keywords"> <!-- Hidden input to store comma-separated string -->
                        </div>
                    </div>
                    <div class="card-actions" style="padding-top:0;">
                         <button id="save-log-btn" class="button button-primary button-full-width">
                            <span class="button-icon" data-icon="save"></span> Save Log
                        </button>
                        <button id="btn-cancel-edit-log" class="button button-subtle button-full-width hidden" style="margin-top: 6px;">
                            <span class="button-icon" data-icon="x-circle"></span> Cancel Edit
                        </button>
                    </div>
                    <input type="hidden" id="editing-log-id"> 
                </article>

                <h3 class="section-title mt-2">Saved Logs for this Video</h3>
                <div id="saved-logs-list" aria-live="polite" aria-atomic="true">
                    <!-- Saved logs will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="modal-new-project" class="modal" role="dialog" aria-labelledby="modal-new-project-title" aria-modal="true">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title" id="modal-new-project-title">Create New Project</h3>
                    <button class="close-button" data-modal-id="modal-new-project" aria-label="Close new project dialog"><span data-icon="close"></span></button>
                </div>
                <div class="form-group">
                    <label for="new-project-name">Project Name:</label>
                    <input type="text" id="new-project-name">
                </div>
                <button id="btn-create-project-confirm" class="button button-primary button-full-width">
                     <span class="button-icon" data-icon="plus-circle"></span> Create Project
                </button>
            </div>
        </div>
        
        <div id="modal-rename-project" class="modal" role="dialog" aria-labelledby="modal-rename-project-title" aria-modal="true">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title" id="modal-rename-project-title">Rename Project</h3>
                    <button class="close-button" data-modal-id="modal-rename-project" aria-label="Close rename project dialog"><span data-icon="close"></span></button>
                </div>
                <input type="hidden" id="rename-project-id">
                <div class="form-group">
                    <label for="rename-project-name-input">New Project Name:</label>
                    <input type="text" id="rename-project-name-input">
                </div>
                <button id="btn-rename-project-confirm" class="button button-primary button-full-width">
                     <span class="button-icon" data-icon="save"></span> Save Changes
                </button>
            </div>
        </div>

        <div id="modal-confirm-action" class="modal" role="dialog" aria-labelledby="modal-confirm-action-title" aria-modal="true">
            <div class="modal-content">
                 <div class="modal-header">
                    <h3 class="modal-title" id="modal-confirm-action-title">Confirm Action</h3>
                    <button class="close-button" data-modal-id="modal-confirm-action" aria-label="Close confirmation dialog"><span data-icon="close"></span></button>
                </div>
                <p id="confirm-action-message" style="margin-bottom: 24px; font-size: 1.05em; line-height: 1.5;">Are you sure?</p>
                <div class="card-actions" style="margin-top:0; padding:0;"> <!-- No padding for modal actions -->
                    <button id="btn-confirm-action-cancel" class="button button-subtle">Cancel</button>
                    <button id="btn-confirm-action-confirm" class="button button-danger">Confirm</button>
                </div>
            </div>
        </div>

        <canvas id="thumbnail-canvas" style="display:none;"></canvas>
        <div id="toast-container" aria-live="assertive" aria-atomic="true"></div>
    </div>

    <script>
    // --- START WORKER SCRIPT (to be inlined) ---
    const thumbnailWorkerScript = `
        self.onmessage = async (event) => {
            const { type, imageData, videoFile, time, canvasWidth, canvasHeight, messageId } = event.data; // CAPTURE messageId
            let blob = null;
            let error = null;

            try {
                if (type === 'fromImageBitmap') {
                    const offscreenCanvas = new OffscreenCanvas(canvasWidth, canvasHeight);
                    const ctx = offscreenCanvas.getContext('2d');
                    ctx.drawImage(imageData, 0, 0, canvasWidth, canvasHeight);
                    if (imageData && typeof imageData.close === 'function') { // Close the received ImageBitmap
                        imageData.close();
                    }
                    blob = await offscreenCanvas.convertToBlob({ type: 'image/jpeg', quality: 0.8 });
                } else if (type === 'fromVideoFile') {
                    // This path is more complex as HTMLVideoElement is not directly available.
                    // The main thread should handle video loading/seeking and send an ImageBitmap.
                    error = 'fromVideoFile direct processing in worker not fully implemented without ImageBitmap';
                }
            } catch (e) {
                error = e.message;
                if (imageData && typeof imageData.close === 'function') { // Ensure cleanup on error too
                   try { imageData.close(); } catch (closeError) { /* console.error('Worker: Error closing ImageBitmap in catch:', closeError); */ }
                }
            }

            if (blob) {
                self.postMessage({ success: true, blob, messageId }); // ECHO BACK messageId
            } else {
                self.postMessage({ success: false, error: error || 'Failed to generate thumbnail in worker', messageId }); // ECHO BACK messageId
            }
        };
    `;
    // --- END WORKER SCRIPT ---

    const app = {
        icons: { // Lucide Icons (https://lucide.dev/)
            'plus': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
            'upload': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>',
            'download': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>',
            'arrow-left': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>',
            'home': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>',
            'video': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 8-6 4 6 4V8Z"></path><rect x="2" y="6" width="14" height="12" rx="2" ry="2"></rect></svg>',
            'rewind': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon></svg>', 
            'play': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>',
            'pause': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>',
            'forward': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon></svg>', 
            'mark-in': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 17V3"></path><path d="m6 11 6 6 6-6"></path><path d="M21 17H3"></path></svg>', 
            'mark-out': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 7V21"></path><path d="m6 13 6-6 6 6"></path><path d="M21 7H3"></path></svg>', 
            'star-outline': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
            'star-filled': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
            'save': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>',
            'close': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
            'plus-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>',
            'trash': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>',
            'pencil': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>',
            'play-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon></svg>',
            'stop-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect></svg>',
            'info-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>',
            'check-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>',
            'x-circle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>',
            'alert-triangle': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
            'folder': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>',
            'film': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line></svg>',
            'document-text': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>',
            'spinner': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>',
            'x-sm': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
        },
        getIcon(name, additionalClasses = '') {
            const svgString = this.icons[name] || this.icons['plus']; // Fallback
            if (additionalClasses) {
                return svgString.replace('<svg ', `<svg class="${additionalClasses}" `);
            }
            return svgString;
        },
        injectAllIcons() {
            document.querySelectorAll('[data-icon]').forEach(el => {
                const iconName = el.dataset.icon;
                const existingContent = el.innerHTML; // Keep existing text if any
                el.innerHTML = this.getIcon(iconName) + existingContent; 
                el.removeAttribute('data-icon'); 
            });
        },
        
        // --- Data Manager for Metadata (LogReelProDB_V3) ---
        DataManager: {
            db: null,
            dbName: 'LogReelProDB_V3',
            version: 1,

            initDB() {
                return new Promise((resolve, reject) => {
                    if (this.db) {
                        resolve(this.db);
                        return;
                    }
                    if (!window.indexedDB) {
                        console.warn("DataManager: IndexedDB not supported.");
                        return reject("IndexedDB not supported");
                    }
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = (event) => {
                        console.error("DataManager DB error:", event.target.error);
                        reject("DataManager DB error: " + event.target.error);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("DataManager DB initialized:", this.dbName);
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('projects')) {
                            db.createObjectStore('projects', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('videos')) {
                            const videoStore = db.createObjectStore('videos', { keyPath: 'id' });
                            videoStore.createIndex('projectId', 'projectId', { unique: false });
                        }
                        if (!db.objectStoreNames.contains('logs')) {
                            const logStore = db.createObjectStore('logs', { keyPath: 'id' });
                            logStore.createIndex('videoId', 'videoId', { unique: false });
                            logStore.createIndex('projectId', 'projectId', { unique: false }); // For cascading deletes by project
                        }
                        console.log("DataManager DB upgrade complete for:", this.dbName);
                    };
                });
            },

            _getStore(storeName, mode = 'readonly') {
                if (!this.db) throw new Error("DataManager DB not initialized.");
                return this.db.transaction(storeName, mode).objectStore(storeName);
            },

            // Project CRUD
            async addProject(projectData) {
                const store = this._getStore('projects', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.add(projectData);
                    req.onsuccess = () => resolve(projectData); // IDB auto-assigns if keyPath and id is there
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getProjectById(projectId) {
                const store = this._getStore('projects');
                return new Promise((resolve, reject) => {
                    const req = store.get(projectId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getAllProjects() {
                const store = this._getStore('projects');
                return new Promise((resolve, reject) => {
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async updateProject(projectData) {
                const store = this._getStore('projects', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.put(projectData);
                    req.onsuccess = () => resolve(projectData);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async deleteProject(projectId) {
                // Delete associated logs first
                const logStore = this._getStore('logs', 'readwrite');
                const logIndex = logStore.index('projectId');
                const logCursorReq = logIndex.openCursor(IDBKeyRange.only(projectId));
                await new Promise((resolve, reject) => {
                    logCursorReq.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            logStore.delete(cursor.primaryKey);
                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                    logCursorReq.onerror = (e) => reject(e.target.error);
                });
                
                // Delete associated videos
                const videoStore = this._getStore('videos', 'readwrite');
                const videoIndex = videoStore.index('projectId');
                const videoCursorReq = videoIndex.openCursor(IDBKeyRange.only(projectId));
                 await new Promise((resolve, reject) => {
                    videoCursorReq.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            videoStore.delete(cursor.primaryKey);
                            // Also delete source file via app.idb
                            app.idb.deleteFile(cursor.primaryKey).catch(err => console.warn("Failed to delete source file on project delete:", err));
                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                    videoCursorReq.onerror = (e) => reject(e.target.error);
                });

                // Delete project
                const projectStore = this._getStore('projects', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = projectStore.delete(projectId);
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            // Video CRUD
            async addVideo(videoData) { // Expects mainVideoThumbnail as Blob
                const store = this._getStore('videos', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.add(videoData);
                    req.onsuccess = () => resolve(videoData);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getVideoById(videoId) {
                const store = this._getStore('videos');
                return new Promise((resolve, reject) => {
                    const req = store.get(videoId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getVideosByProjectId(projectId) {
                const store = this._getStore('videos');
                const index = store.index('projectId');
                return new Promise((resolve, reject) => {
                    const req = index.getAll(projectId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async updateVideo(videoData) { // Expects mainVideoThumbnail as Blob
                const store = this._getStore('videos', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.put(videoData);
                    req.onsuccess = () => resolve(videoData);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async deleteVideo(videoId) {
                // Delete associated logs
                const logStore = this._getStore('logs', 'readwrite');
                const logIndex = logStore.index('videoId');
                const logCursorReq = logIndex.openCursor(IDBKeyRange.only(videoId));
                 await new Promise((resolve, reject) => {
                    logCursorReq.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            logStore.delete(cursor.primaryKey);
                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                    logCursorReq.onerror = (e) => reject(e.target.error);
                });
                // Delete video metadata
                const videoStore = this._getStore('videos', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = videoStore.delete(videoId);
                    // Also delete source file via app.idb
                    app.idb.deleteFile(videoId).catch(err => console.warn("Failed to delete source file on video delete:", err));
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e.target.error);
                });
            },

            // Log CRUD
            async addLog(logData) { // Expects thumbnail as Blob
                const store = this._getStore('logs', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.add(logData);
                    req.onsuccess = () => resolve(logData);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getLogById(logId) {
                const store = this._getStore('logs');
                return new Promise((resolve, reject) => {
                    const req = store.get(logId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async getLogsByVideoId(videoId) {
                const store = this._getStore('logs');
                const index = store.index('videoId');
                return new Promise((resolve, reject) => {
                    const req = index.getAll(videoId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async updateLog(logData) { // Expects thumbnail as Blob
                const store = this._getStore('logs', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.put(logData);
                    req.onsuccess = () => resolve(logData);
                    req.onerror = (e) => reject(e.target.error);
                });
            },
            async deleteLog(logId) {
                const store = this._getStore('logs', 'readwrite');
                return new Promise((resolve, reject) => {
                    const req = store.delete(logId);
                    req.onsuccess = () => resolve();
                    req.onerror = (e) => reject(e.target.error);
                });
            }
        },
        // --- End Data Manager ---

        data: {
            projects: [], // In-memory representation, loaded from DataManager
            currentProjectId: null,
            currentVideoId: null, 
            videoElement: null, 
            timelineProgress: null,
            timelineContainer: null,
            playPauseBtn: null, 
            rewindBtn: null, 
            forwardBtn: null, 
            timecodeDisplay: null, 
            speedSelect: null, 
            markInBtn: null,
            markOutBtn: null,
            markInTime: 0,
            markOutTime: null,
            currentRating: 0,
            videoFileCache: {}, // For ObjectURLs of source video Files from app.idb
            
            activeCardPlayer: {
                videoId: null, cardElement: null, playerElement: null, thumbnailElement: null,
                bigPlayButtonElement: null, promptElement: null, fileInputElement: null, 
                controlsContainerElement: null, playPauseBtnElement: null, rewindBtnElement: null,
                forwardBtnElement: null, progressBarContainerElement: null, progressBarElement: null,
                timecodeElement: null, stopBtnElement: null, speedSelectElement: null, // ADDED
                isPlaying: false, isScrubbing: false,
                wasPlayingBeforeScrub: false, currentSegment: { startTime: 0, endTime: 0, duration: 0 }, 
                boundPlayerTimeUpdate: null, boundPlayerLoadedMetadata: null, boundPlayerEnded: null,
                boundPlayerError: null, boundPlayerPlay: null, boundPlayerPause: null, boundSpeedChange: null, // ADDED boundSpeedChange
                _boundCardPlayerScrubMove: null, _boundCardPlayerScrubEnd: null,
                controlsHideTimer: null, 
            },
            previouslyFocusedElement: null,
            skipTimeSeconds: 5, 
            isScrubbing: false, 
            wasPlayingBeforeScrub: false, 
            scrollPositions: {},
            currentEditingProjectId: null,
            logKeywordsData: [],
            activeObjectURLs: {}, // To manage thumbnail ObjectURLs: e.g., { 'log-uuid': 'blob:...', 'video-uuid': 'blob:...' }
            thumbnailWorker: null,
        },
        dom: {}, 
        idb: { // This remains for video SOURCE files (LogReelFilesDB_v2)
            db: null,
            dbName: 'LogReelFilesDB_v2', 
            storeName: 'videoFiles',
            version: 1,

            initDB() { 
                return new Promise((resolve, reject) => {
                    if (app.idb.db) {
                        resolve(app.idb.db);
                        return;
                    }
                    if (!window.indexedDB) {
                        console.warn("SourceFileDB: IndexedDB not supported by this browser.");
                        reject("IndexedDB not supported");
                        return;
                    }
                    const request = indexedDB.open(app.idb.dbName, app.idb.version);

                    request.onerror = (event) => {
                        console.error("SourceFileDB: IndexedDB error:", event.target.error);
                        reject("SourceFileDB error: " + event.target.error);
                    };

                    request.onsuccess = (event) => {
                        app.idb.db = event.target.result;
                        console.log("SourceFileDB: IndexedDB initialized successfully for:", app.idb.dbName);
                        resolve(app.idb.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(app.idb.storeName)) {
                            db.createObjectStore(app.idb.storeName, { keyPath: 'videoId' });
                            console.log("SourceFileDB: IndexedDB object store created for:", app.idb.dbName);
                        }
                    };
                });
            },

            storeFile(videoId, file) { 
                return new Promise(async (resolve, reject) => {
                    try {
                        if (!app.idb.db) { 
                             try {
                                await app.idb.initDB();
                            } catch (initError) {
                                reject(initError); 
                                return;
                            }
                        }
                        if (!app.idb.db) { 
                           reject("SourceFileDB: IndexedDB not available for storing file.");
                           return;
                        }
                        const transaction = app.idb.db.transaction([app.idb.storeName], 'readwrite');
                        const store = transaction.objectStore(app.idb.storeName);
                        const request = store.put({ videoId: videoId, file: file });

                        request.onsuccess = () => resolve();
                        request.onerror = (event) => {
                            console.error("SourceFileDB: Error storing file in IndexedDB:", event.target.error);
                            reject(event.target.error);
                        };
                    } catch (error) {
                        console.error("SourceFileDB: Exception in storeFile:", error);
                        reject(error);
                    }
                });
            },

            retrieveFile(videoId) { 
                return new Promise(async (resolve, reject) => {
                    try {
                        if (!app.idb.db) {
                            try {
                                await app.idb.initDB();
                            } catch (initError) {
                                reject(initError);
                                return;
                            }
                        }
                         if (!app.idb.db) {
                           reject("SourceFileDB: IndexedDB not available for retrieving file.");
                           return;
                        }
                        const transaction = app.idb.db.transaction([app.idb.storeName], 'readonly');
                        const store = transaction.objectStore(app.idb.storeName);
                        const request = store.get(videoId);

                        request.onsuccess = (event) => {
                            if (event.target.result) {
                                resolve(event.target.result.file);
                            } else {
                                resolve(null); 
                            }
                        };
                        request.onerror = (event) => {
                            console.error("SourceFileDB: Error retrieving file from IndexedDB:", event.target.error);
                            reject(event.target.error);
                        };
                    } catch (error) {
                        console.error("SourceFileDB: Exception in retrieveFile:", error);
                        reject(error);
                    }
                });
            },

            deleteFile(videoId) { 
                return new Promise(async (resolve, reject) => {
                    try {
                        if (!app.idb.db) {
                             try {
                                await app.idb.initDB();
                            } catch (initError) {
                                reject(initError);
                                return;
                            }
                        }
                        if (!app.idb.db) {
                           reject("SourceFileDB: IndexedDB not available for deleting file.");
                           return;
                        }
                        const transaction = app.idb.db.transaction([app.idb.storeName], 'readwrite');
                        const store = transaction.objectStore(app.idb.storeName);
                        const request = store.delete(videoId);

                        request.onsuccess = () => resolve();
                        request.onerror = (event) => {
                            console.error("SourceFileDB: Error deleting file from IndexedDB:", event.target.error);
                            reject(event.target.error);
                        };
                    } catch (error) {
                        console.error("SourceFileDB: Exception in deleteFile:", error);
                        reject(error);
                    }
                });
            }
        },
        utils: {
            generateId() { 
                return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
            },
            formatTime(seconds, includeMillis = false) { 
                if (isNaN(seconds) || seconds < 0) return includeMillis ? '00:00.0' : '00:00';
                const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60); const ms = Math.floor((seconds - Math.floor(seconds)) * 10); 
                let timeStr = ''; if (h > 0) timeStr += `${String(h).padStart(2, '0')}:`;
                timeStr += `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                if (includeMillis) timeStr += `.${ms}`; return timeStr;
            },
            escapeHtml(unsafe) { 
                if (typeof unsafe !== 'string') return String(unsafe);
                return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            },
            removeSessionStorageItem(key) {
                try {
                    sessionStorage.removeItem(key);
                } catch (e) {
                    console.warn(`Could not remove ${key} from sessionStorage:`, e);
                }
            },
            dataURLtoBlob(dataurl) {
                if (!dataurl || typeof dataurl !== 'string' || !dataurl.includes(',')) return null;
                try {
                    var arr = dataurl.split(','), mimeMatch = arr[0].match(/:(.*?);/);
                    if (!mimeMatch || !mimeMatch[1]) return null;
                    var mime = mimeMatch[1],
                        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
                    while(n--){
                        u8arr[n] = bstr.charCodeAt(n);
                    }
                    return new Blob([u8arr], {type:mime});
                } catch (e) {
                    console.error("Error in dataURLtoBlob:", e);
                    return null;
                }
            }
        },

        init() {
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            this.cacheDomElements();
            this.injectAllIcons(); 
            this.boundHandleTimelineMouseMove = this.handleTimelineMouseMove.bind(this);
            this.boundHandleTimelineMouseUp = this.handleTimelineMouseUp.bind(this);
            this.boundHandleTimelineTouchMove = this.handleTimelineTouchMove.bind(this);
            this.boundHandleTimelineTouchEnd = this.handleTimelineTouchEnd.bind(this);
            
            this.loadScrollPositionsFromSessionStorage(); 

            // Initialize Thumbnail Worker
            try {
                const workerBlob = new Blob([thumbnailWorkerScript], { type: 'application/javascript' });
                this.data.thumbnailWorker = new Worker(URL.createObjectURL(workerBlob));
                this.data.thumbnailWorker.onmessage = (event) => {
                    // This is a generic handler; specific promises will handle their own resolutions.
                    // console.log("Worker replied:", event.data);
                };
                this.data.thumbnailWorker.onerror = (error) => {
                    console.error('Thumbnail Worker Error:', error);
                    this.showToast('Thumbnail generation service failed.', 'error', 5000, 'x-circle');
                    this.data.thumbnailWorker = null; // Disable worker if it errors out
                };
            } catch (e) {
                console.error("Failed to initialize thumbnail worker:", e);
                this.data.thumbnailWorker = null;
            }


            // Initialize both DBs
            Promise.all([
                this.idb.initDB().catch(error => { // Source files DB
                    console.warn("Failed to initialize SourceFileDB. App will rely on file selection prompts.", error);
                    this.showToast("Persistent video file storage unavailable.", "warning", 7000, 'alert-triangle');
                }),
                this.DataManager.initDB().catch(error => { // Metadata DB
                    console.error("Failed to initialize DataManager DB (Metadata). App may not function correctly.", error);
                    this.showToast("Critical: Metadata storage failed to initialize.", "error", 10000, 'x-circle');
                    // Potentially halt app or go to a degraded mode. For now, it will try to continue.
                })
            ])
            .then(async () => {
                await this.loadData(); // Load data after DBs are ready
                this.registerEventListeners();
                this.adjustHeaderSpacers(); // Initial call
                this.navigateTo('screen-projects');
                console.log("LogReel Pro App Initialized");
            })
            .catch(err => {
                 console.error("Fatal error during DB initialization sequence:", err);
                 document.body.innerHTML = "<p style='padding:20px; text-align:center;'>Application critical error: Could not initialize databases. Please try clearing site data or using a different browser.</p>";
            });
        },

        loadScrollPositionsFromSessionStorage() {
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                if (key && key.startsWith('scrollPos_')) {
                    const originalKey = key.substring('scrollPos_'.length);
                    const value = sessionStorage.getItem(key);
                    if (value !== null) {
                        const numericValue = parseInt(value, 10);
                        if (!isNaN(numericValue)) {
                            this.data.scrollPositions[originalKey] = numericValue;
                        }
                    }
                }
            }
        },

        adjustHeaderSpacers() {
            requestAnimationFrame(() => {
                 const adjustSpacer = (actionsContainerId, spacerId) => {
                    const actionsContainer = document.getElementById(actionsContainerId);
                    const spacer = document.getElementById(spacerId);
                    if (actionsContainer && spacer) {
                        if (actionsContainer.offsetWidth > 0) {
                           spacer.style.width = `${actionsContainer.offsetWidth}px`;
                        }
                    }
                };
                adjustSpacer('project-videos-header-left-actions', 'project-videos-header-spacer');
                adjustSpacer('video-logging-header-left-actions', 'video-logging-header-spacer');
            });
        },


        cacheDomElements() {
            this.dom.screens = {
                'projects': document.getElementById('screen-projects'),
                'project-videos': document.getElementById('screen-project-videos'),
                'video-logging': document.getElementById('screen-video-logging'),
            };
            this.dom.modals = {
                newProject: document.getElementById('modal-new-project'),
                renameProject: document.getElementById('modal-rename-project'), 
                confirmAction: document.getElementById('modal-confirm-action'),
            };
            this.dom.toastContainer = document.getElementById('toast-container');
            this.dom.projectsList = document.getElementById('projects-list');
            this.dom.btnNewProject = document.getElementById('btn-new-project');
            this.dom.importProjectsInput = document.getElementById('import-projects-input');
            
            this.dom.btnBackToProjects = document.getElementById('btn-back-to-projects');
            this.dom.btnHomeFromProjectVideos = document.getElementById('btn-home-from-project-videos');
            this.dom.projectNameHeader = document.getElementById('project-name-header');
            this.dom.projectVideosHeaderSpacer = document.getElementById('project-videos-header-spacer');
            this.dom.btnExportProject = document.getElementById('btn-export-project');
            this.dom.projectVideosSearch = document.getElementById('project-videos-search');
            this.dom.projectVideosContainer = document.getElementById('project-videos-container');
            this.dom.bottomAddVideosBar = document.getElementById('bottom-add-videos-bar'); 

            this.dom.btnBackToProjectVideos = document.getElementById('btn-back-to-project-videos');
            this.dom.btnHomeFromVideoLogging = document.getElementById('btn-home-from-video-logging');
            this.dom.videoFilenameHeader = document.getElementById('video-filename-header');
            this.dom.videoLoggingHeaderSpacer = document.getElementById('video-logging-header-spacer');
            this.data.videoElement = document.getElementById('video-player'); 
            this.dom.videoPlayerContainer = document.getElementById('video-player-container'); 
            this.dom.videoFilePrompt = document.getElementById('video-file-prompt');
            this.dom.videoFilePromptMessage = document.getElementById('video-file-prompt-message');
            this.dom.videoFileInputLogging = document.getElementById('video-file-input-logging');
            this.data.timelineContainer = document.getElementById('timeline-container');
            this.data.timelineProgress = document.getElementById('timeline-progress');

            this.data.rewindBtn = document.getElementById('rewind-btn');
            this.data.playPauseBtn = document.getElementById('play-pause-btn');
            this.data.forwardBtn = document.getElementById('forward-btn');
            this.data.timecodeDisplay = document.getElementById('timecode-display');
            this.data.speedSelect = document.getElementById('speed-select');
            
            this.data.markInBtn = document.getElementById('mark-in-btn');
            this.data.markOutBtn = document.getElementById('mark-out-btn');
            this.dom.logNotes = document.getElementById('log-notes');
            this.dom.logRatingContainer = document.getElementById('log-rating');
            
            this.dom.logKeywordsContainer = document.getElementById('log-keywords-container');
            this.dom.logKeywordsInputField = document.getElementById('log-keywords-input-field');
            this.dom.logKeywordsHidden = document.getElementById('log-keywords');

            this.dom.saveLogBtn = document.getElementById('save-log-btn');
            this.dom.btnCancelEditLog = document.getElementById('btn-cancel-edit-log');
            this.dom.editingLogIdInput = document.getElementById('editing-log-id');
            this.dom.savedLogsList = document.getElementById('saved-logs-list');
            this.dom.thumbnailCanvas = document.getElementById('thumbnail-canvas'); 

            this.dom.newProjectNameInput = document.getElementById('new-project-name');
            this.dom.btnCreateProjectConfirm = document.getElementById('btn-create-project-confirm');
            
            this.dom.renameProjectIdInput = document.getElementById('rename-project-id');
            this.dom.renameProjectNameInput = document.getElementById('rename-project-name-input');
            this.dom.btnRenameProjectConfirm = document.getElementById('btn-rename-project-confirm');

            this.dom.confirmActionMessage = document.getElementById('confirm-action-message');
            this.dom.btnConfirmActionCancel = document.getElementById('btn-confirm-action-cancel');
            this.dom.btnConfirmActionConfirm = document.getElementById('btn-confirm-action-confirm');
        },

        revokeActiveObjectURL(key) {
            if (this.data.activeObjectURLs[key]) {
                URL.revokeObjectURL(this.data.activeObjectURLs[key]);
                delete this.data.activeObjectURLs[key];
            }
        },

        revokeAllActiveObjectURLsForPrefix(prefix) {
            for (const key in this.data.activeObjectURLs) {
                if (key.startsWith(prefix)) {
                    URL.revokeObjectURL(this.data.activeObjectURLs[key]);
                    delete this.data.activeObjectURLs[key];
                }
            }
        },
        
        async navigateTo(screenId, params = {}) {
            // --- Save current scroll positions (contextual) ---
            if (this.currentScreen) {
                let scrollKey, scrollValue, listScrollKey, listScrollValue;

                if (this.currentScreen === 'screen-projects') {
                    scrollKey = 'screen-projects';
                    scrollValue = window.pageYOffset;
                } else if (this.currentScreen === 'screen-project-videos' && this.data.currentProjectId) {
                    scrollKey = 'screen-project-videos-' + this.data.currentProjectId;
                    scrollValue = window.pageYOffset;

                    if (this.dom.projectVideosContainer) {
                        this.dom.projectVideosContainer.querySelectorAll('article.video-entry-card').forEach(cardElement => {
                            const videoId = cardElement.dataset.videoId;
                            if (videoId) {
                                const clipListContainer = cardElement.querySelector('.video-clips-list-container');
                                if (clipListContainer && clipListContainer.scrollHeight > clipListContainer.clientHeight) {
                                    const s2ClipListKey = `s2_clipsList_${this.data.currentProjectId}_${videoId}`;
                                    const s2ClipListScrollValue = clipListContainer.scrollTop;
                                    this.data.scrollPositions[s2ClipListKey] = s2ClipListScrollValue;
                                    try {
                                        sessionStorage.setItem('scrollPos_' + s2ClipListKey, s2ClipListScrollValue.toString());
                                    } catch (e) {
                                        console.warn("Could not save Screen 2 clip list scroll position to sessionStorage:", e);
                                    }
                                }
                            }
                        });
                    }

                } else if (this.currentScreen === 'screen-video-logging' && this.data.currentProjectId && this.data.currentVideoId) {
                    scrollKey = 'screen-video-logging-window-' + this.data.currentProjectId + '-' + this.data.currentVideoId;
                    scrollValue = window.pageYOffset;

                    if (this.dom.savedLogsList) { 
                        listScrollKey = 'videoLogsList-' + this.data.currentProjectId + '-' + this.data.currentVideoId;
                        listScrollValue = this.dom.savedLogsList.scrollTop;
                    }
                }

                if (scrollKey !== undefined && scrollValue !== undefined) {
                    this.data.scrollPositions[scrollKey] = scrollValue;
                    try {
                        sessionStorage.setItem('scrollPos_' + scrollKey, scrollValue.toString());
                    } catch (e) { console.warn("Could not save scroll position to sessionStorage:", e); }
                }
                if (listScrollKey !== undefined && listScrollValue !== undefined) {
                    this.data.scrollPositions[listScrollKey] = listScrollValue;
                    try {
                        sessionStorage.setItem('scrollPos_' + listScrollKey, listScrollValue.toString());
                    } catch (e) { console.warn("Could not save list scroll position to sessionStorage:", e); }
                }
            }
            // --- End Save current scroll positions ---

            const targetScreenKey = screenId.replace('screen-', '');
            
            Object.values(this.dom.screens).forEach(screen => {
                if (screen) screen.classList.remove('active');
            });
            
            if (this.dom.screens[targetScreenKey]) {
                this.dom.screens[targetScreenKey].classList.add('active');
            } else {
                console.error(`Screen key "${targetScreenKey}" not found in this.dom.screens.`);
                if (this.dom.screens['projects']) {
                     this.dom.screens['projects'].classList.add('active');
                } else {
                    document.body.innerHTML = "<p style='padding:20px; text-align:center;'>Application Error: UI cannot be initialized.</p>"; return; 
                }
                screenId = 'screen-projects'; 
            }
            
            this.currentScreen = screenId;
            this.adjustHeaderSpacers(); 
            window.scrollTo(0, 0); 

            if (this.data.activeCardPlayer.playerElement && screenId !== 'screen-project-videos') {
                this.resetActiveCardPlayerUI(); 
            }

            if (this.data.videoElement) { 
                if (screenId === 'screen-video-logging') {
                    this.data.videoElement.removeAttribute('controls');
                } else {
                    this.data.videoElement.pause(); 
                }
            }
            
            if (screenId === 'screen-project-videos' && params && params.projectId) {
                this.data.currentProjectId = params.projectId;
            } else if (screenId === 'screen-video-logging' && params && params.projectId && params.videoId) {
                this.data.currentProjectId = params.projectId;
                this.data.currentVideoId = params.videoId;
            }

            const restoreScroll = () => {
                requestAnimationFrame(() => {
                    if (screenId === 'screen-projects') {
                        if (typeof this.data.scrollPositions['screen-projects'] === 'number') {
                            window.scrollTo(0, this.data.scrollPositions['screen-projects']);
                        }
                    } else if (screenId === 'screen-project-videos' && this.data.currentProjectId) {
                        const key = 'screen-project-videos-' + this.data.currentProjectId;
                        if (typeof this.data.scrollPositions[key] === 'number') {
                            window.scrollTo(0, this.data.scrollPositions[key]);
                        }
                        // Clip list scroll restoration is now primarily handled within renderProjectVideosScreen
                        // to ensure it happens *after* the DOM is fully re-rendered by that function.
                        // However, this.data.scrollPositions can still be a source if renderProjectVideosScreen
                        // decides not to fully re-render certain elements in future optimizations.

                    } else if (screenId === 'screen-video-logging' && this.data.currentProjectId && this.data.currentVideoId) {
                        const windowKey = 'screen-video-logging-window-' + this.data.currentProjectId + '-' + this.data.currentVideoId;
                        if (typeof this.data.scrollPositions[windowKey] === 'number') {
                            window.scrollTo(0, this.data.scrollPositions[windowKey]);
                        }

                        // Saved logs list scroll restoration is handled by renderVideoLoggingScreen calling renderSavedLogsList,
                        // which now has its own internal scroll restoration.
                    }
                });
            };

            switch (screenId) {
                case 'screen-projects':
                    this.revokeAllActiveObjectURLsForPrefix('project-'); 
                    this.revokeAllActiveObjectURLsForPrefix('video-');
                    this.revokeAllActiveObjectURLsForPrefix('log-');
                    await this.renderProjectsScreen();
                    restoreScroll(); // Restore window scroll for screen-projects
                    break;
                case 'screen-project-videos':
                    this.revokeAllActiveObjectURLsForPrefix('log-'); 
                    if (!this.data.currentProjectId && this.data.projects.length > 0) {
                         this.data.currentProjectId = this.data.projects[0].id; 
                    } else if (!this.data.currentProjectId) {
                        this.navigateTo('screen-projects'); return; 
                    }
                    // `renderProjectVideosScreen` will handle its own scroll restoration internally now.
                    // `restoreScroll()` will just set the initial window scroll for this screen.
                    await this.renderProjectVideosScreen(); 
                    restoreScroll(); 
                    break;
                case 'screen-video-logging':
                     this.revokeAllActiveObjectURLsForPrefix('video-'); 
                     if (!this.data.currentProjectId || !this.data.currentVideoId) {
                        const targetProjectId = this.data.currentProjectId || (this.data.projects.length > 0 ? this.data.projects[0].id : null);
                        if(targetProjectId) this.navigateTo('screen-project-videos', { projectId: targetProjectId });
                        else this.navigateTo('screen-projects');
                        return;
                    }
                    // `renderVideoLoggingScreen` and `renderSavedLogsList` will handle their own scroll restoration.
                    await this.renderVideoLoggingScreen(); 
                    if(params && params.logIdToEdit) {
                        await this.editLogEntry(params.logIdToEdit, true);
                    }
                    restoreScroll(); // Restore window scroll for screen-video-logging
                    break;
            }
        },

        async loadData() { 
            const migrationDone = localStorage.getItem('logReelProDB_V3_migrated_ls');
            if (!migrationDone) {
                const oldDataLs = localStorage.getItem('logReelData');
                if (oldDataLs) {
                    this.showToast('Migrating old data from LocalStorage...', 'info', 5000, 'info-circle');
                    try {
                        const parsedOldData = JSON.parse(oldDataLs);
                        if (Array.isArray(parsedOldData)) {
                            for (const project of parsedOldData) {
                                const newProject = { 
                                    id: project.id || this.utils.generateId(), 
                                    name: project.name, 
                                    createdAt: project.createdAt || new Date(0).toISOString(),
                                    // videos array will be populated below
                                };
                                await this.DataManager.addProject(newProject);

                                if (project.videos && Array.isArray(project.videos)) {
                                    for (const video of project.videos) {
                                        let mainThumbBlob = null;
                                        if (video.mainVideoThumbnail && typeof video.mainVideoThumbnail === 'string') {
                                            mainThumbBlob = this.utils.dataURLtoBlob(video.mainVideoThumbnail);
                                        }
                                        const newVideo = {
                                            id: video.id || this.utils.generateId(),
                                            projectId: newProject.id,
                                            filename: video.filename,
                                            createdAt: video.createdAt || new Date(0).toISOString(),
                                            isImportant: video.isImportant || false,
                                            mainVideoThumbnail: mainThumbBlob, // Store as Blob
                                            // logs array will be populated below
                                        };
                                        await this.DataManager.addVideo(newVideo);

                                        if (video.logs && Array.isArray(video.logs)) {
                                            for (const log of video.logs) {
                                                let logThumbBlob = null;
                                                if (log.thumbnail && typeof log.thumbnail === 'string') {
                                                    logThumbBlob = this.utils.dataURLtoBlob(log.thumbnail);
                                                }
                                                let keywordsArray = [];
                                                if (log.keywords) {
                                                    if (typeof log.keywords === 'string') {
                                                        keywordsArray = log.keywords.split(',').map(k => k.trim()).filter(k => k);
                                                    } else if (Array.isArray(log.keywords)) {
                                                        keywordsArray = log.keywords;
                                                    }
                                                }
                                                const newLog = {
                                                    id: log.id || this.utils.generateId(),
                                                    videoId: newVideo.id,
                                                    projectId: newProject.id,
                                                    markIn: log.markIn,
                                                    markOut: log.markOut,
                                                    notes: log.notes,
                                                    rating: log.rating,
                                                    keywords: keywordsArray,
                                                    thumbnail: logThumbBlob, // Store as Blob
                                                    createdAt: log.createdAt || new Date(0).toISOString()
                                                };
                                                await this.DataManager.addLog(newLog);
                                            }
                                        }
                                    }
                                }
                            }
                            localStorage.setItem('logReelProDB_V3_migrated_ls', 'true');
                            localStorage.removeItem('logReelData'); // Clear old data
                            this.showToast('Migration complete!', 'success', 3000, 'check-circle');
                        }
                    } catch (e) {
                        console.error("Error migrating data from localStorage:", e);
                        this.showToast("Error migrating old data. Some data might be lost.", "error", 7000, 'x-circle');
                    }
                } else {
                     localStorage.setItem('logReelProDB_V3_migrated_ls', 'true'); // No old LS data to migrate
                }
            }

            // Load all data from DataManager into app.data.projects
            this.data.projects = [];
            try {
                const projectsFromDB = await this.DataManager.getAllProjects();
                for (const project of projectsFromDB) {
                    const videosForProject = await this.DataManager.getVideosByProjectId(project.id);
                    project.videos = [];
                    for (const video of videosForProject) {
                        const logsForVideo = await this.DataManager.getLogsByVideoId(video.id);
                        video.logs = logsForVideo;
                        project.videos.push(video);
                    }
                    this.data.projects.push(project);
                }
            } catch (err) {
                console.error("Error loading data from DataManager:", err);
                this.showToast("Could not load all project data.", "error", 5000, 'x-circle');
            }
        },
        
        getProjectById(projectId) { return this.data.projects.find(p => p.id === projectId); },
        getVideoById(projectId, videoId) { const project = this.getProjectById(projectId); return project ? project.videos.find(v => v.id === videoId) : null; },
        getLogById(projectId, videoId, logId) { const video = this.getVideoById(projectId, videoId); return video && video.logs ? video.logs.find(l => l.id === logId) : null; },

        registerEventListeners() {
            this.dom.btnNewProject.addEventListener('click', () => this.showNewProjectModal());
            this.dom.importProjectsInput.addEventListener('change', (e) => this.importProjects(e));
            this.dom.btnBackToProjects.addEventListener('click', () => this.navigateTo('screen-projects'));
            if (this.dom.btnHomeFromProjectVideos) {
                this.dom.btnHomeFromProjectVideos.addEventListener('click', () => this.navigateTo('screen-projects'));
            }

            this.dom.screens['project-videos'].addEventListener('change', (e) => {
                if (e.target && e.target.classList.contains('add-videos-input-actual')) { 
                    this.handleAddVideos(e.target); 
                }
            });
            
            this.dom.btnExportProject.addEventListener('click', () => this.exportCurrentProject());
            this.dom.projectVideosSearch.addEventListener('input', async (e) => {
                await this.renderProjectVideosScreen(e.target.value.trim());
            });
            this.dom.btnBackToProjectVideos.addEventListener('click', () => this.navigateTo('screen-project-videos', { projectId: this.data.currentProjectId }));
            if (this.dom.btnHomeFromVideoLogging) {
                this.dom.btnHomeFromVideoLogging.addEventListener('click', () => this.navigateTo('screen-projects'));
            }
            
            if(this.data.videoElement) { 
                this.data.rewindBtn.addEventListener('click', () => this.rewindVideo());
                this.data.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
                this.data.forwardBtn.addEventListener('click', () => this.fastForwardVideo());

                this.data.videoElement.addEventListener('play', () => { 
                    if(this.data.playPauseBtn && this.currentScreen === 'screen-video-logging') {
                        const iconSpan = this.data.playPauseBtn.querySelector('.button-icon');
                        if (iconSpan) iconSpan.innerHTML = this.getIcon('pause');
                        this.data.playPauseBtn.setAttribute('aria-label', 'Pause video'); 
                    }
                });
                this.data.videoElement.addEventListener('pause', () => { 
                    if(this.data.playPauseBtn && this.currentScreen === 'screen-video-logging') {
                        const iconSpan = this.data.playPauseBtn.querySelector('.button-icon');
                        if (iconSpan) iconSpan.innerHTML = this.getIcon('play');
                        this.data.playPauseBtn.setAttribute('aria-label', 'Play video'); 
                    }
                });
                this.data.videoElement.addEventListener('loadedmetadata', () => {
                    if (this.currentScreen === 'screen-video-logging') {
                        this.updateVideoTimes();
                        if (this.data.videoElement && this.data.speedSelect) { // Ensure elements exist
                            try {
                                const speedValue = parseFloat(this.data.speedSelect.value);
                                if (!isNaN(speedValue)) {
                                    this.data.videoElement.playbackRate = speedValue;
                                }
                            } catch (error) {
                                console.warn("Could not set initial playback rate for S3 video:", error);
                            }
                        }
                    }
                });
                this.data.videoElement.addEventListener('timeupdate', () => { if(this.currentScreen === 'screen-video-logging') this.updateVideoTimes(); });
                this.data.videoElement.addEventListener('durationchange', () => { if(this.currentScreen === 'screen-video-logging') this.updateVideoTimes(); });
                this.data.videoElement.addEventListener('error', async (e) => { 
                    if(this.currentScreen !== 'screen-video-logging') return;
                    console.error("Video Player Error (Screen 3):", e);
                    const videoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                    this.showToast(`Error playing ${videoData ? this.utils.escapeHtml(videoData.filename) : 'video'}.`, 'error', 5000, 'x-circle');
                    if (videoData) { 
                        const cacheKey = `${this.data.currentProjectId}-${this.data.currentVideoId}`;
                        if(this.data.videoFileCache[cacheKey]) {
                            URL.revokeObjectURL(this.data.videoFileCache[cacheKey]);
                            delete this.data.videoFileCache[cacheKey];
                        }
                        this.promptForVideoFile(videoData.filename);
                    }
                });
            
                this.data.timelineContainer.addEventListener('mousedown', (e) => this.handleTimelineMouseDown(e));
                this.data.timelineContainer.addEventListener('touchstart', (e) => this.handleTimelineTouchStart(e), { passive: false });

                this.data.speedSelect.addEventListener('change', (e) => { if(this.data.videoElement) this.data.videoElement.playbackRate = parseFloat(e.target.value); });
            }
            this.data.markInBtn.addEventListener('click', () => this.setMarkIn());
            this.data.markOutBtn.addEventListener('click', () => this.setMarkOut());
            this.dom.logRatingContainer.addEventListener('click', (e) => this.handleStarRating(e));
            this.dom.saveLogBtn.addEventListener('click', () => this.saveLogEntry()); 
            this.dom.videoFileInputLogging.addEventListener('change', (e) => this.handleVideoFileSelectionForLogging(e.target.files[0])); 
            
            if (this.dom.btnCancelEditLog) {
                this.dom.btnCancelEditLog.addEventListener('click', () => {
                    this.resetLogForm();
                    const logFormCard = this.dom.logNotes.closest('article.card');
                    if (logFormCard) {
                        logFormCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            }

            document.querySelectorAll('.close-button').forEach(btn => {
                btn.addEventListener('click', () => this.hideModal(btn.dataset.modalId));
            });
            this.dom.btnCreateProjectConfirm.addEventListener('click', () => this.createNewProject());
            this.dom.btnRenameProjectConfirm.addEventListener('click', () => this.renameProject()); 
            this.dom.btnConfirmActionCancel.addEventListener('click', () => this.hideModal('modal-confirm-action')); 
            
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const visibleModals = Object.values(this.dom.modals).filter(m => m.classList.contains('visible'));
                    if (visibleModals.length > 0) {
                        this.hideModal(visibleModals[visibleModals.length - 1].id);
                        return; 
                    }
                }

                if (this.currentScreen === 'screen-video-logging' && this.data.videoElement && this.data.videoElement.src && this.dom.videoFilePrompt.classList.contains('hidden')) { 
                    const activeEl = document.activeElement;
                    const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT';
                    
                    if (!isInputFocused) {
                        switch (e.key.toLowerCase()) {
                            case ' ': case 'k': e.preventDefault(); this.togglePlayPause(); break;
                            case 'j': e.preventDefault(); this.rewindVideo(); break;
                            case 'l': e.preventDefault(); this.fastForwardVideo(); break;
                            case 'i': e.preventDefault(); this.setMarkIn(); break;
                            case 'o': e.preventDefault(); this.setMarkOut(); break;
                        }
                    }
                }
            });

            this.dom.projectsList.addEventListener('click', async e => {
                const openBtn = e.target.closest('.btn-open-project');
                const deleteBtn = e.target.closest('.btn-delete-project');
                const editBtn = e.target.closest('.btn-edit-project-name');

                if (openBtn) {
                    this.navigateTo('screen-project-videos', { projectId: openBtn.dataset.projectId });
                } else if (deleteBtn) {
                    await this.confirmDeleteProject(deleteBtn.dataset.projectId);
                } else if (editBtn) {
                    this.showRenameProjectModal(editBtn.dataset.projectId);
                }
            });


            this.dom.projectVideosContainer.addEventListener('click', async (e) => {
                const targetButton = e.target.closest('button');
                if (!targetButton) return;

                const videoEntryCard = targetButton.closest('article.video-entry-card');
                if (!videoEntryCard) return; 
                const videoId = videoEntryCard.dataset.videoId;

                if (targetButton.classList.contains('btn-log-full-video')) {
                    this.navigateTo('screen-video-logging', { projectId: this.data.currentProjectId, videoId: videoId });
                } else if (targetButton.classList.contains('btn-delete-this-video')) {
                    await this.confirmDeleteVideo(videoId);
                } else if (targetButton.classList.contains('btn-toggle-important')) {
                    await this.toggleVideoImportance(videoId);
                } else if (targetButton.classList.contains('btn-play-clip-on-card')) { 
                    const logId = targetButton.dataset.logId;
                    const logData = this.getLogById(this.data.currentProjectId, videoId, logId);
                    if (logData) {
                        await this.playVideoOnCard(videoId, videoEntryCard, { startTime: logData.markIn, endTime: logData.markOut });
                    }
                } else if (targetButton.classList.contains('btn-edit-this-clip')) {
                    const logId = targetButton.dataset.logId;
                    this.navigateTo('screen-video-logging', { projectId: this.data.currentProjectId, videoId: videoId, logIdToEdit: logId });
                } else if (targetButton.classList.contains('btn-delete-this-log-item')) {
                     const logId = targetButton.dataset.logId;
                     await this.confirmDeleteLogItemFromScreen2(videoId, logId);
                } else if (targetButton.classList.contains('play-main-video-preview-btn')) { 
                    await this.playVideoOnCard(videoId, videoEntryCard); 
                } 
                else if (targetButton.classList.contains('main-player-play-pause-btn')) {
                    this.toggleCardPlayerPlayPause();
                } else if (targetButton.classList.contains('main-player-rewind-btn')) {
                    this.rewindCardPlayer();
                } else if (targetButton.classList.contains('main-player-forward-btn')) {
                    this.forwardCardPlayer();
                } else if (targetButton.classList.contains('main-player-stop-btn')) {
                    this.stopAndResetCardPlayer();
                }
            });
            this.dom.projectVideosContainer.addEventListener('mousedown', (e) => { 
                if (e.target.closest('.main-player-progress-bar-container')) { this.handleCardPlayerProgressBarMouseDown(e); }
            });
            this.dom.projectVideosContainer.addEventListener('touchstart', (e) => { 
                if (e.target.closest('.main-player-progress-bar-container')) { this.handleCardPlayerProgressBarTouchStart(e); }
            }, { passive: false });

            this.dom.projectVideosContainer.addEventListener('mouseover', e => {
                const previewArea = e.target.closest('.main-video-preview-area');
                if (previewArea) {
                    const videoId = previewArea.id.replace('main-preview-area-', '');
                    const acp = this.data.activeCardPlayer;
                    if (acp.videoId === videoId && acp.controlsContainerElement && acp.playerElement && acp.playerElement.src && !acp.promptElement.classList.contains('hidden') === false) { 
                        clearTimeout(acp.controlsHideTimer);
                        acp.controlsContainerElement.classList.add('visible');
                    }
                }
            });
            this.dom.projectVideosContainer.addEventListener('mouseout', e => {
                 const previewArea = e.target.closest('.main-video-preview-area');
                 if (previewArea) {
                    const videoId = previewArea.id.replace('main-preview-area-', '');
                    const acp = this.data.activeCardPlayer;
                     if (acp.videoId === videoId && acp.controlsContainerElement && acp.playerElement && acp.playerElement.src && !acp.isPlaying) {
                        acp.controlsHideTimer = setTimeout(() => {
                             if(acp.controlsContainerElement) acp.controlsContainerElement.classList.remove('visible');
                        }, 2000);
                     }
                 }
            });

            this.dom.projectVideosContainer.addEventListener('change', async (e) => {
                if (e.target.classList.contains('main-video-preview-file-input')) {
                    const videoId = e.target.dataset.targetPlayerId; 
                    if (!this.data.activeCardPlayer.videoId || this.data.activeCardPlayer.videoId === videoId) {
                         await this.handleCardPlayerFileSelection(e.target.files[0], videoId);
                    }
                }
            });

            this.dom.logKeywordsInputField.addEventListener('keydown', e => this.handleKeywordInputKeydown(e));
            this.dom.logKeywordsContainer.addEventListener('click', e => {
                if (e.target.closest('.remove-tag-btn')) {
                    const tagText = e.target.closest('.tag-item').firstChild.textContent.trim();
                    this.removeKeywordTag(tagText);
                }
            });
            this.dom.logKeywordsInputField.addEventListener('paste', e => this.handleKeywordInputPaste(e));

            window.addEventListener('resize', () => this.adjustHeaderSpacers());
        },
        
        async getVideoSource(projectId, videoId, videoFilename) {
            const cacheKey = `${projectId}-${videoId}`; // For source video file ObjectURLs
            if (this.data.videoFileCache[cacheKey]) {
                try {
                    const response = await fetch(this.data.videoFileCache[cacheKey]); 
                    if (response.ok) { return this.data.videoFileCache[cacheKey]; } 
                    else { URL.revokeObjectURL(this.data.videoFileCache[cacheKey]); delete this.data.videoFileCache[cacheKey]; }
                } catch (e) { if (this.data.videoFileCache[cacheKey]) URL.revokeObjectURL(this.data.videoFileCache[cacheKey]); delete this.data.videoFileCache[cacheKey];}
            }
            try {
                const fileFromDB = await this.idb.retrieveFile(videoId); // from LogReelFilesDB_v2
                if (fileFromDB && fileFromDB.name === videoFilename) {
                    const objectURL = URL.createObjectURL(fileFromDB); this.data.videoFileCache[cacheKey] = objectURL; return objectURL;
                } else if (fileFromDB && fileFromDB.name !== videoFilename) { console.warn(`Filename mismatch from IDB. Expected ${videoFilename}, got ${fileFromDB.name}.`); }
            } catch (error) { if (error !== "IndexedDB not supported" && error !== "IndexedDB not available for retrieving file.") this.showToast(`Error accessing storage for "${this.utils.escapeHtml(videoFilename)}".`, "warning", 3000, 'alert-triangle'); }
            return null;
        },
        
        _createOrUpdateProjectCard(project, existingCard = null) {
            const cardDataId = `project-${project.id}`;
            let creationDateText = 'N/A';
            if (project.createdAt) { try { creationDateText = new Date(project.createdAt).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }); } catch (e) {} }

            if (existingCard) { // Update existing
                existingCard.querySelector('.card-title').textContent = this.utils.escapeHtml(project.name);
                existingCard.querySelector('.card-meta').textContent = `Contains ${project.videos ? project.videos.length : 0} video(s)  Created: ${creationDateText}`;
                return existingCard;
            } else { // Create new
                const card = document.createElement('article');
                card.className = 'card';
                card.dataset.projectId = project.id;
                
                card.innerHTML = `
                    <div class="card-padding-wrapper" style="padding: 24px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div>
                                <div class="card-title">${this.utils.escapeHtml(project.name)}</div>
                                <div class="card-meta">
                                    Contains ${project.videos ? project.videos.length : 0} video(s) &bull; Created: ${creationDateText}
                                </div>
                            </div>
                            <button class="button button-subtle button-small btn-edit-project-name" data-project-id="${project.id}" aria-label="Rename project">
                                <span class="button-icon">${this.getIcon('pencil')}</span>
                            </button>
                        </div>
                    </div>
                    <div class="card-actions">
                        <button class="button button-primary btn-open-project" data-project-id="${project.id}">Open Project</button>
                        <button class="button button-subtle btn-delete-project" data-project-id="${project.id}">
                            <span class="button-icon">${this.getIcon('trash')}</span> Delete
                        </button>
                    </div>
                `; 
                return card;
            }
        },

        async renderProjectsScreen() {
            if (!this.dom.projectsList) return;
            
            let previousScrollY = 0;
            if (this.currentScreen === 'screen-projects') { // Only save if currently on this screen
                previousScrollY = window.pageYOffset;
            }

            const projectsContainer = this.dom.projectsList;
            const existingProjectCards = new Map();
            projectsContainer.querySelectorAll('article.card[data-project-id]').forEach(card => {
                existingProjectCards.set(card.dataset.projectId, card);
            });

            if (this.data.projects.length === 0) {
                existingProjectCards.forEach(card => this.revokeActiveObjectURL(`project-${card.dataset.projectId}`)); 
                projectsContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">${this.getIcon('folder')}</div>
                        <p>No projects yet.</p>
                        <p>Create one or import existing projects to get started!</p>
                    </div>`;
                if (this.currentScreen === 'screen-projects') { // Restore even for empty
                    requestAnimationFrame(() => { window.scrollTo(0, previousScrollY); });
                }
                return;
            }

            const fragment = document.createDocumentFragment();
            this.data.projects.sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt)); 

            for (const project of this.data.projects) {
                const existingCard = existingProjectCards.get(project.id);
                const cardElement = this._createOrUpdateProjectCard(project, existingCard);
                fragment.appendChild(cardElement);
                if (existingCard) {
                    existingProjectCards.delete(project.id); 
                }
            }
            
            existingProjectCards.forEach((card, projectId) => {
                this.revokeActiveObjectURL(`project-${projectId}`); 
                card.remove();
            });
            
            projectsContainer.innerHTML = ''; 
            projectsContainer.appendChild(fragment);

            if (this.currentScreen === 'screen-projects') {
                requestAnimationFrame(() => {
                    window.scrollTo(0, previousScrollY);
                });
            }
        },
        async showNewProjectModal() { 
            this.dom.newProjectNameInput.value = '';
            this.showModal('modal-new-project');
            this.dom.newProjectNameInput.focus();
        },
        async createNewProject() { 
            const name = this.dom.newProjectNameInput.value.trim();
            if (!name) { this.showToast('Project name cannot be empty.', 'warning', 3000, 'alert-triangle'); return; }
            
            const newProjectData = { 
                id: this.utils.generateId(), 
                name: name, 
                videos: [], 
                createdAt: new Date().toISOString() 
            };

            try {
                await this.DataManager.addProject({ id: newProjectData.id, name: newProjectData.name, createdAt: newProjectData.createdAt });
                this.data.projects.unshift(newProjectData); 
                await this.renderProjectsScreen(); 
                this.hideModal('modal-new-project');
                this.showToast(`Project "${this.utils.escapeHtml(name)}" created.`, 'success', 3000, 'check-circle');
            } catch (err) {
                console.error("Error creating project:", err);
                this.showToast("Failed to create project in database.", "error", 5000, 'x-circle');
            }
        },
        showRenameProjectModal(projectId) {
            const project = this.getProjectById(projectId);
            if (!project) return;
            this.data.currentEditingProjectId = projectId;
            this.dom.renameProjectIdInput.value = projectId;
            this.dom.renameProjectNameInput.value = project.name;
            this.showModal('modal-rename-project');
            this.dom.renameProjectNameInput.focus();
        },
        async renameProject() {
            const projectId = this.dom.renameProjectIdInput.value;
            const newName = this.dom.renameProjectNameInput.value.trim();
            const project = this.getProjectById(projectId);

            if (!project) { this.showToast('Error: Project not found.', 'error', 3000, 'x-circle'); return; }
            if (!newName) { this.showToast('Project name cannot be empty.', 'warning', 3000, 'alert-triangle'); return; }
            if (newName === project.name) { this.hideModal('modal-rename-project'); return; }

            const updatedProjectData = { ...project, name: newName };
            const projectToStore = { id: updatedProjectData.id, name: updatedProjectData.name, createdAt: updatedProjectData.createdAt };

            try {
                await this.DataManager.updateProject(projectToStore);
                project.name = newName; 
                await this.renderProjectsScreen(); 
                if (this.data.currentProjectId === projectId && this.dom.projectNameHeader) { this.dom.projectNameHeader.textContent = this.utils.escapeHtml(newName); }
                this.hideModal('modal-rename-project');
                this.showToast(`Project renamed to "${this.utils.escapeHtml(newName)}".`, 'success', 3000, 'check-circle');
            } catch (err) {
                console.error("Error renaming project:", err);
                this.showToast("Failed to rename project in database.", "error", 5000, 'x-circle');
            }
            this.data.currentEditingProjectId = null;
        },
        async confirmDeleteProject(projectId) { 
            const project = this.getProjectById(projectId);
            if (!project) return;
            const message = `Are you sure you want to delete the project "<strong>${this.utils.escapeHtml(project.name)}</strong>"? <br>This action cannot be undone and will remove all associated video files from persistent storage.`;
            this.showConfirmationModal(
                message, 
                async () => await this.deleteProject(projectId), 
                null, 
                { text: 'Delete Project', icon: 'trash', class: 'button-danger' }
            );
        },
        async deleteProject(projectId){ 
            const projectToDelete = this.getProjectById(projectId);
            if (!projectToDelete) return;
        
            try {
                await this.DataManager.deleteProject(projectId);
        
                this.utils.removeSessionStorageItem('scrollPos_screen-project-videos-' + projectId);
                if (projectToDelete.videos) { 
                    projectToDelete.videos.forEach(video => {
                        this.utils.removeSessionStorageItem('scrollPos_screen-video-logging-window-' + projectId + '-' + video.id);
                        this.utils.removeSessionStorageItem('scrollPos_videoLogsList-' + projectId + '-' + video.id);
                        this.utils.removeSessionStorageItem(`scrollPos_s2_clipsList_${projectId}_${video.id}`);
                        this.revokeActiveObjectURL(`video-${video.id}`);
                        if (video.logs) {
                            video.logs.forEach(log => this.revokeActiveObjectURL(`log-${log.id}`));
                        }
                        const cacheKey = `${projectId}-${video.id}`;
                        if (this.data.videoFileCache[cacheKey]) {
                            URL.revokeObjectURL(this.data.videoFileCache[cacheKey]);
                            delete this.data.videoFileCache[cacheKey];
                        }
                    });
                }
        
                this.data.projects = this.data.projects.filter(p => p.id !== projectId);
                
                delete this.data.scrollPositions['screen-project-videos-' + projectId];
                if (projectToDelete.videos) {
                    projectToDelete.videos.forEach(video => {
                        delete this.data.scrollPositions['screen-video-logging-window-' + projectId + '-' + video.id];
                        delete this.data.scrollPositions['videoLogsList-' + projectId + '-' + video.id];
                        delete this.data.scrollPositions[`s2_clipsList_${projectId}_${video.id}`];
                    });
                }
        
                if (this.data.currentProjectId === projectId) { this.data.currentProjectId = null; this.data.currentVideoId = null; }
                await this.renderProjectsScreen();
                this.showToast(`Project "${this.utils.escapeHtml(projectToDelete.name)}" deleted.`, 'success', 3000, 'check-circle');
            } catch (err) {
                console.error("Error deleting project:", err);
                this.showToast(`Failed to delete project "${this.utils.escapeHtml(projectToDelete.name)}".`, "error", 5000, 'x-circle');
            }
        },
        
        async importProjects(event) { 
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e_reader) => {
                    try {
                        const importedData = JSON.parse(e_reader.target.result);
                        if (Array.isArray(importedData) && importedData.every(p => p.id && p.name && Array.isArray(p.videos))) {
                            
                            this.showConfirmationModal(
                                "This will add the projects from the file as <strong>new projects</strong>. Video files will need re-adding manually. Continue?",
                                async () => { 
                                    let importCount = 0;
                                    for (const importedProject of importedData) {
                                        const newProjectId = this.utils.generateId();
                                        const projectToStore = {
                                            id: newProjectId,
                                            name: importedProject.name,
                                            createdAt: importedProject.createdAt || new Date().toISOString()
                                        };
                                        await this.DataManager.addProject(projectToStore);
                                        const projectForMemory = { ...projectToStore, videos: [] };

                                        if (importedProject.videos && Array.isArray(importedProject.videos)) {
                                            for (const importedVideo of importedProject.videos) {
                                                const newVideoId = this.utils.generateId();
                                                let mainThumbBlob = null;
                                                if (importedVideo.mainVideoThumbnail && typeof importedVideo.mainVideoThumbnail === 'string' && importedVideo.mainVideoThumbnail.startsWith('data:image')) {
                                                    mainThumbBlob = this.utils.dataURLtoBlob(importedVideo.mainVideoThumbnail);
                                                }

                                                const videoToStore = {
                                                    id: newVideoId,
                                                    projectId: newProjectId,
                                                    filename: importedVideo.filename,
                                                    createdAt: importedVideo.createdAt || new Date().toISOString(),
                                                    isImportant: importedVideo.isImportant || false,
                                                    mainVideoThumbnail: mainThumbBlob 
                                                };
                                                await this.DataManager.addVideo(videoToStore);
                                                const videoForMemory = { ...videoToStore, logs: [] };

                                                if (importedVideo.logs && Array.isArray(importedVideo.logs)) {
                                                    for (const importedLog of importedVideo.logs) {
                                                        let logThumbBlob = null;
                                                         if (importedLog.thumbnail && typeof importedLog.thumbnail === 'string' && importedLog.thumbnail.startsWith('data:image')) {
                                                            logThumbBlob = this.utils.dataURLtoBlob(importedLog.thumbnail);
                                                        }
                                                        let keywordsArray = [];
                                                        if (importedLog.keywords) {
                                                            if (typeof importedLog.keywords === 'string') {
                                                                keywordsArray = importedLog.keywords.split(',').map(k => k.trim()).filter(k => k);
                                                            } else if (Array.isArray(importedLog.keywords)) {
                                                                keywordsArray = importedLog.keywords;
                                                            }
                                                        }
                                                        const logToStore = {
                                                            id: this.utils.generateId(),
                                                            videoId: newVideoId,
                                                            projectId: newProjectId,
                                                            markIn: importedLog.markIn,
                                                            markOut: importedLog.markOut,
                                                            notes: importedLog.notes,
                                                            rating: importedLog.rating,
                                                            keywords: keywordsArray,
                                                            thumbnail: logThumbBlob,
                                                            createdAt: importedLog.createdAt || new Date().toISOString(),
                                                            updatedAt: importedLog.updatedAt 
                                                        };
                                                        await this.DataManager.addLog(logToStore);
                                                        videoForMemory.logs.push(logToStore);
                                                    }
                                                }
                                                projectForMemory.videos.push(videoForMemory);
                                            }
                                        }
                                        this.data.projects.unshift(projectForMemory); 
                                        importCount++;
                                    }
                                    await this.renderProjectsScreen();
                                    this.showToast(`${importCount} project(s) imported. Video source files need to be selected for each video.`, 'success', 7000, 'check-circle');
                                },
                                null, 
                                { text: 'Import & Add', icon: 'plus-circle', class: 'button-primary' }
                            );
                        } else { this.showToast('Invalid project file format.', 'error', 3000, 'x-circle'); }
                    } catch (error) { this.showToast('Error reading project file.', 'error', 3000, 'x-circle'); console.error("Import error:", error); }
                };
                reader.readAsText(file); event.target.value = null; 
            }
        },
        async exportCurrentProject() {
            const projectInMemory = this.getProjectById(this.data.currentProjectId);
            if (!projectInMemory) { this.showToast("No project selected.", "warning", 3000, 'alert-triangle'); return; }

            // Create a new structure specifically for export, manually copying and converting.
            const projectForExportPayload = {
                id: projectInMemory.id,
                name: projectInMemory.name,
                createdAt: projectInMemory.createdAt,
                videos: []
            };

            const blobToDataURL = (blob) => {
                return new Promise((resolve, reject) => {
                    if (!blob || !(blob instanceof Blob)) { // Check for Blob instance
                        resolve(null); 
                        return;
                    }
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            for (const video of projectInMemory.videos) { // Iterate over the ORIGINAL projectInMemory.videos
                const videoCopyForExport = {
                    id: video.id,
                    projectId: video.projectId,
                    filename: video.filename,
                    createdAt: video.createdAt,
                    isImportant: video.isImportant,
                    mainVideoThumbnail: null, // Initialize
                    logs: []
                };

                // Convert mainVideoThumbnail
                if (video.mainVideoThumbnail instanceof Blob) {
                    try {
                        videoCopyForExport.mainVideoThumbnail = await blobToDataURL(video.mainVideoThumbnail);
                    } catch (e) {
                        console.error("Error converting main thumbnail Blob to DataURL for video:", video.filename, e);
                        videoCopyForExport.mainVideoThumbnail = null;
                    }
                } else if (typeof video.mainVideoThumbnail === 'string' && video.mainVideoThumbnail.startsWith('data:image')) {
                    videoCopyForExport.mainVideoThumbnail = video.mainVideoThumbnail; // It's already a DataURL
                } else {
                    console.warn(`Main thumbnail for ${this.utils.escapeHtml(video.filename)} was not a Blob or DataURL. Exporting as null.`);
                    videoCopyForExport.mainVideoThumbnail = null;
                }
                
                for (const log of video.logs) { // Iterate over original logs
                    const logCopyForExport = { ...log, thumbnail: null }; // Base copy, initialize thumbnail
                    
                    if (log.thumbnail instanceof Blob) {
                        try {
                            logCopyForExport.thumbnail = await blobToDataURL(log.thumbnail);
                        } catch (e) {
                           console.error("Error converting log thumbnail Blob to DataURL for log in video:", video.filename, e);
                           logCopyForExport.thumbnail = null;
                        }
                    } else if (typeof log.thumbnail === 'string' && log.thumbnail.startsWith('data:image')) {
                         logCopyForExport.thumbnail = log.thumbnail; // It's already a DataURL
                    } else {
                        logCopyForExport.thumbnail = null;
                    }
                    videoCopyForExport.logs.push(logCopyForExport);
                }
                projectForExportPayload.videos.push(videoCopyForExport);
            }
             
            const dataStr = JSON.stringify([projectForExportPayload], null, 2); 
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportFileDefaultName = `${projectForExportPayload.name.replace(/\s+/g, '_')}_LogReel_export.json`;
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri); linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click(); linkElement.remove();
            this.showToast(`Project "${this.utils.escapeHtml(projectForExportPayload.name)}" export started.`, 'success', 3000, 'check-circle');
        },
        
        _createOrUpdateVideoCard(video, index, searchTerm = '') {
            const cardDataId = `video-${video.id}`;
            this.revokeActiveObjectURL(cardDataId); 

            let mainThumbnailSrc = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 160 90"%3E%3Crect width="160" height="90" fill="%23E0E7FF"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="14px" fill="%236B7280"%3ENo Preview%3C/text%3E%3C/svg%3E'; // IMPROVED PLACEHOLDER
            
            if (video.mainVideoThumbnail instanceof Blob && video.mainVideoThumbnail.size > 0) { // ADDED SIZE CHECK
                mainThumbnailSrc = URL.createObjectURL(video.mainVideoThumbnail);
                this.data.activeObjectURLs[cardDataId] = mainThumbnailSrc;
            } else if (typeof video.mainVideoThumbnail === 'string' && video.mainVideoThumbnail.startsWith('data:image')) { 
                mainThumbnailSrc = video.mainVideoThumbnail;
            }
            
            let clipsHtml = '';
            let clipsToDisplay = video.logs || [];
            if (searchTerm) {
                const lowerSearchTerm = searchTerm.toLowerCase();
                clipsToDisplay = clipsToDisplay.filter(log =>
                    log.notes.toLowerCase().includes(lowerSearchTerm) ||
                    (log.keywords && Array.isArray(log.keywords) && log.keywords.some(k => k.toLowerCase().includes(lowerSearchTerm)))
                );
            }

            if (clipsToDisplay.length > 0) {
                clipsToDisplay.sort((a,b) => a.markIn - b.markIn).forEach(log => {
                    const logThumbId = `log-${log.id}`;
                    this.revokeActiveObjectURL(logThumbId);
                    let logThumbSrc = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='; // Transparent pixel
                    if (log.thumbnail instanceof Blob && log.thumbnail.size > 0) { // ADDED SIZE CHECK
                        logThumbSrc = URL.createObjectURL(log.thumbnail);
                        this.data.activeObjectURLs[logThumbId] = logThumbSrc;
                    } else if (typeof log.thumbnail === 'string' && log.thumbnail.startsWith('data:image')) { 
                        logThumbSrc = log.thumbnail;
                    }

                    const ratingStars = Array(5).fill(0).map((_, i) => 
                        this.getIcon(i < log.rating ? 'star-filled' : 'star-outline', `star-icon ${i < log.rating ? 'filled' : 'empty'}`)
                    ).join('');
                    const keywordsText = (log.keywords && Array.isArray(log.keywords) && log.keywords.length > 0) 
                        ? `<p class="keywords">Keywords: ${this.utils.escapeHtml(log.keywords.join(', '))}</p>` 
                        : '';

                    clipsHtml += `
                        <div class="clip-item-card" data-log-id="${log.id}">
                            <img src="${logThumbSrc}" alt="Clip thumbnail" class="clip-item-thumbnail">
                            <div class="clip-item-info">
                                <p class="notes">${this.utils.escapeHtml(log.notes)}</p>
                                <p class="time">Time: ${this.utils.formatTime(log.markIn)} - ${this.utils.formatTime(log.markOut)}</p>
                                <p class="rating-display">Rating: ${ratingStars}</p>
                                ${keywordsText}
                            </div>
                            <div class="clip-item-actions">
                                <button class="button button-primary button-small btn-play-clip-on-card" data-log-id="${log.id}" aria-label="Play clip"><span class="button-icon">${this.getIcon('play')}</span> Play</button>
                                <button class="button button-subtle button-small btn-edit-this-clip" data-log-id="${log.id}" aria-label="Edit clip"><span class="button-icon">${this.getIcon('pencil')}</span> Edit</button>
                                <button class="button button-subtle button-small btn-delete-this-log-item" data-log-id="${log.id}" aria-label="Delete clip"><span class="button-icon">${this.getIcon('trash')}</span> Del</button>
                            </div>
                        </div>
                    `;
                });
            } else if (searchTerm && video.filename.toLowerCase().includes(searchTerm.toLowerCase())) { 
                clipsHtml = '<p style="padding: 10px 0; text-align:center; color: var(--text-color-light); font-size:0.9em;">No logged clips match search for this video.</p>';
            } else if (!searchTerm) {
                 clipsHtml = '<p style="padding: 10px 0; text-align:center; color: var(--text-color-light); font-size:0.9em;">No clips logged for this video yet.</p>';
            }

            const videoCard = document.createElement('article');
            videoCard.className = 'video-entry-card';
            videoCard.dataset.videoId = video.id;
            videoCard.innerHTML = `
                <div class="video-entry-header">
                    <span class="video-entry-title" title="${this.utils.escapeHtml(video.filename)}">
                       <span class="video-card-number">${index + 1}. </span>${this.utils.escapeHtml(video.filename)}
                    </span>
                    <div class="video-entry-actions">
                         <button class="button button-subtle button-small btn-toggle-important ${video.isImportant ? 'is-important' : ''}" title="${video.isImportant ? 'Unmark as important' : 'Mark as important'}" aria-pressed="${video.isImportant}">
                            <span class="button-icon">${this.getIcon(video.isImportant ? 'star-filled' : 'star-outline')}</span>
                        </button>
                        <button class="button button-secondary button-small btn-log-full-video" aria-label="Log full video"><span class="button-icon">${this.getIcon('document-text')}</span> Log Full Video</button>
                        <button class="button button-subtle button-small btn-delete-this-video" aria-label="Delete video"><span class="button-icon">${this.getIcon('trash')}</span> Delete Video</button>
                    </div>
                </div>
                <div class="main-video-preview-area" id="main-preview-area-${video.id}">
                    <img src="${mainThumbnailSrc}" class="main-video-thumbnail" id="main-thumbnail-${video.id}" alt="Video preview for ${this.utils.escapeHtml(video.filename)}">
                    <button class="play-main-video-preview-btn" id="play-main-preview-btn-${video.id}" aria-label="Play video preview">
                        ${this.getIcon('play-circle')} 
                    </button>
                    <video class="main-video-preview-player hidden" id="main-player-${video.id}" playsinline width="100%"></video>
                    <div class="main-video-preview-prompt hidden" id="main-player-prompt-${video.id}">
                        <p id="main-player-prompt-msg-${video.id}">Select video file to play preview.</p>
                        <label class="button button-primary button-small mt-1">
                            <span class="button-icon">${this.getIcon('video')}</span> Select Video File
                            <input type="file" class="main-video-preview-file-input" data-target-player-id="${video.id}" accept="video/*" aria-label="Select video file">
                        </label>
                    </div>
                    <div class="main-player-custom-controls" id="main-player-controls-${video.id}">
                        <button class="main-player-ctrl-btn main-player-rewind-btn" aria-label="Rewind 5 seconds"><span class="button-icon">${this.getIcon('rewind')}</span></button>
                        <button class="main-player-ctrl-btn main-player-play-pause-btn" aria-label="Play"><span class="button-icon">${this.getIcon('play')}</span></button>
                        <button class="main-player-ctrl-btn main-player-forward-btn" aria-label="Forward 5 seconds"><span class="button-icon">${this.getIcon('forward')}</span></button>
                        <div class="main-player-progress-bar-container">
                            <div class="main-player-progress-bar" id="main-player-progress-${video.id}"></div>
                        </div>
                        <div class="main-player-speed-control-group">
                            <label for="main-player-speed-select-${video.id}" class="sr-only">Playback Speed:</label>
                            <select id="main-player-speed-select-${video.id}" class="main-player-speed-select" aria-label="Playback speed">
                                <option value="0.5">0.5x</option>
                                <option value="0.75">0.75x</option>
                                <option value="1">1x</option>
                                <option value="1.25">1.25x</option>
                                <option value="1.5">1.5x</option>
                                <option value="2">2x</option>
                                <option value="2.5">2.5x</option>
                                <option value="3" selected>3x</option>
                            </select>
                        </div>
                        <span class="main-player-timecode" id="main-player-timecode-${video.id}">00:00 / 00:00</span>
                        <button class="main-player-ctrl-btn main-player-stop-btn" aria-label="Stop playback and show thumbnail"><span class="button-icon">${this.getIcon('stop-circle')}</span></button>
                    </div>
                </div>
                <div class="video-clips-list-container">
                    ${clipsToDisplay.length > 0 || (searchTerm && video.filename.toLowerCase().includes(searchTerm.toLowerCase())) ? `<h4>Logged Clips (${clipsToDisplay.length})</h4>` : ''}
                    ${clipsHtml}
                </div>
            `;
            return videoCard;
        },

        async renderProjectVideosScreen(searchTerm = '') {
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) {
                this.navigateTo('screen-projects');
                return;
            }
            this.dom.projectNameHeader.textContent = this.utils.escapeHtml(project.name);

            let previousScrollY = window.pageYOffset;
            const previousClipListScrolls = new Map();
            // Capture scroll positions from existing DOM elements BEFORE clearing/modifying them
            if (this.dom.projectVideosContainer && this.dom.projectVideosContainer.firstChild) { 
                this.dom.projectVideosContainer.querySelectorAll('article.video-entry-card[data-video-id]').forEach(card => {
                    const videoId = card.dataset.videoId;
                    const clipList = card.querySelector('.video-clips-list-container');
                    if (videoId && clipList) { // Store current scroll top, even if 0
                        previousClipListScrolls.set(videoId, clipList.scrollTop);
                    }
                });
            }

            const videosContainer = this.dom.projectVideosContainer;
            const existingVideoCards = new Map();
            videosContainer.querySelectorAll('article.video-entry-card[data-video-id]').forEach(card => {
                existingVideoCards.set(card.dataset.videoId, card);
                card.querySelectorAll('.clip-item-card[data-log-id]').forEach(clipCard => {
                    this.revokeActiveObjectURL(`log-${clipCard.dataset.logId}`);
                });
            });

            if (this.data.activeCardPlayer.playerElement) this.resetActiveCardPlayerUI();

            let videosToDisplay = project.videos || [];
            let foundItems = false;
            const fragment = document.createDocumentFragment();
            
            if (videosToDisplay.length === 0 && !searchTerm) {
                existingVideoCards.forEach((card, videoId) => this.revokeActiveObjectURL(`video-${videoId}`));
                videosContainer.innerHTML = `
                    <div class="empty-state" style="margin:20px;">
                        <div class="empty-state-icon">${this.getIcon('film')}</div>
                        <p>No videos in this project yet.</p>
                        <p>Click "Add Videos" to begin.</p>
                    </div>`;
                if (this.dom.bottomAddVideosBar) this.dom.bottomAddVideosBar.classList.add('hidden');
                requestAnimationFrame(() => { window.scrollTo(0, previousScrollY); });
                return;
            }
            
            videosToDisplay.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt));

            videosToDisplay.forEach((video, index) => {
                let videoMatchesSearch = false;
                if (searchTerm) {
                    const lowerSearchTerm = searchTerm.toLowerCase();
                    if (video.filename.toLowerCase().includes(lowerSearchTerm)) videoMatchesSearch = true;
                    const clipsMatch = (video.logs || []).some(log =>
                        log.notes.toLowerCase().includes(lowerSearchTerm) ||
                        (log.keywords && log.keywords.some(k => k.toLowerCase().includes(lowerSearchTerm)))
                    );
                    if (!videoMatchesSearch && !clipsMatch) return;
                }
                foundItems = true;

                const existingCard = existingVideoCards.get(video.id);
                if (existingCard) {
                     this.revokeActiveObjectURL(`video-${video.id}`); 
                     existingCard.remove(); 
                }
                const videoCardElement = this._createOrUpdateVideoCard(video, index, searchTerm);
                fragment.appendChild(videoCardElement);
                existingVideoCards.delete(video.id); 
            });
            
            existingVideoCards.forEach((card, videoId) => {
                this.revokeActiveObjectURL(`video-${videoId}`);
                card.remove();
            });

            videosContainer.innerHTML = ''; 
            videosContainer.appendChild(fragment); 
            
            if (!foundItems && searchTerm) {
                 videosContainer.innerHTML = `<div class="empty-state" style="margin:20px;"><p>No videos or clips found matching "<strong>${this.utils.escapeHtml(searchTerm)}</strong>".</p></div>`;
            } else if (!foundItems && !searchTerm && videosToDisplay.length > 0) { 
                 videosContainer.innerHTML = '<div class="empty-state" style="margin:20px;"><p>No videos to display.</p></div>'; 
            }

            requestAnimationFrame(() => {
                window.scrollTo(0, previousScrollY);
                if (this.dom.projectVideosContainer) {
                    this.dom.projectVideosContainer.querySelectorAll('article.video-entry-card[data-video-id]').forEach(card => {
                        const videoId = card.dataset.videoId;
                        const clipList = card.querySelector('.video-clips-list-container');
                        if (videoId && clipList) {
                            const scrollKey = `s2_clipsList_${this.data.currentProjectId}_${videoId}`;
                            let targetScrollTop = 0;

                            // Priority 1: Value from sessionStorage (loaded into this.data.scrollPositions during init)
                            if (typeof this.data.scrollPositions[scrollKey] === 'number') {
                                targetScrollTop = this.data.scrollPositions[scrollKey];
                            }
                            // Priority 2: Value captured just before this re-render (for in-session navigation)
                            else if (previousClipListScrolls.has(videoId)) {
                                targetScrollTop = previousClipListScrolls.get(videoId);
                            }

                            if (targetScrollTop > 0 && clipList.scrollHeight > clipList.clientHeight) {
                                clipList.scrollTop = targetScrollTop;
                            }
                        }
                    });
                }
            });

            if (this.dom.bottomAddVideosBar) {
                if (project.videos && project.videos.length > 2) {
                    this.dom.bottomAddVideosBar.classList.remove('hidden');
                } else {
                    this.dom.bottomAddVideosBar.classList.add('hidden');
                }
            }
        },

        async handleAddVideos(inputElement) { 
            const files = inputElement.files;
            const project = this.getProjectById(this.data.currentProjectId);
            
            if (!project) { this.showToast("Project context not found.", "error"); return; }
            if (!files || files.length === 0) { return; }

            const addVideosButtonLabel = inputElement.closest('label.add-videos-button-label');
            if (addVideosButtonLabel) this.setButtonLoadingState(addVideosButtonLabel, true, 'Adding...');

            let addedCount = 0;
            const baseTime = Date.now(); 
            try {
                for (let i = 0; i < files.length; i++) { 
                    let file = files[i];
                    if (file.type.startsWith('video/')) {
                        const videoId = this.utils.generateId();
                        let mainThumbnailBlob = null;
                        
                        try { 
                            await this.idb.storeFile(videoId, file); 
                        } catch (error) {
                            this.showToast(`Could not save "${this.utils.escapeHtml(file.name)}" source persistently.`, 'warning', 6000, 'alert-triangle');
                        }

                        try {
                             mainThumbnailBlob = await this.generateGenericThumbnailFromFile(file);
                             if (!mainThumbnailBlob) console.warn("Thumbnail for", file.name, "is null/undefined after generation during add.");
                        } catch (e) { 
                            console.error("CRITICAL: Could not generate main thumbnail for new video:", file.name, e);
                            mainThumbnailBlob = null; 
                        }
                        
                        const newVideoData = { 
                            id: videoId, 
                            projectId: project.id,
                            filename: file.name, 
                            createdAt: new Date(baseTime + i).toISOString(), 
                            isImportant: false, 
                            mainVideoThumbnail: mainThumbnailBlob 
                        };
                        await this.DataManager.addVideo(newVideoData); 
                        
                        const projectInMemory = this.getProjectById(project.id);
                        if (projectInMemory) {
                            if(!projectInMemory.videos) projectInMemory.videos = [];
                            projectInMemory.videos.push({ ...newVideoData, logs: [] }); 
                        }
                        addedCount++;
                    } else { 
                        this.showToast(`File "${this.utils.escapeHtml(file.name)}" is not a video.`, 'warning', 3000, 'alert-triangle'); 
                    }
                }

                if(addedCount > 0) {
                    await this.renderProjectVideosScreen(); 
                    this.showToast(`${addedCount} video(s) added.`, 'success', 3000, 'check-circle');
                }
            } catch (error) {
                console.error("Error in handleAddVideos loop:", error);
                this.showToast("An error occurred while processing videos.", "error", 5000, 'x-circle');
            } finally {
                if (addVideosButtonLabel) {
                    this.setButtonLoadingState(addVideosButtonLabel, false);
                    const currentFileInputInLabel = addVideosButtonLabel.querySelector('.add-videos-input-actual');
                    if (currentFileInputInLabel) currentFileInputInLabel.value = null; 
                } else if (inputElement) inputElement.value = null;
            }
        },
        
        _postToThumbnailWorker(data) {
            return new Promise((resolve, reject) => {
                if (!this.data.thumbnailWorker) {
                    reject(new Error("Thumbnail worker not available."));
                    return;
                }
                const messageId = this.utils.generateId(); 
                const timeout = setTimeout(() => {
                    reject(new Error("Thumbnail worker timeout"));
                    this.data.thumbnailWorker.removeEventListener('message', specificMessageHandler);
                }, 7000); 

                const specificMessageHandler = (event) => {
                    if (event.data && event.data.messageId === messageId) {
                        clearTimeout(timeout);
                        this.data.thumbnailWorker.removeEventListener('message', specificMessageHandler);
                        if (event.data.success) {
                            resolve(event.data.blob);
                        } else {
                            reject(new Error(event.data.error || "Worker failed to generate thumbnail"));
                        }
                    }
                };
                this.data.thumbnailWorker.addEventListener('message', specificMessageHandler);
                this.data.thumbnailWorker.postMessage({ ...data, messageId });
            });
        },
        
        async _generateThumbnailFromVideoElement(videoElement, time, forLog = false) {
            return new Promise(async (resolve, reject) => {
                if (!videoElement || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                    if (videoElement && videoElement.readyState < videoElement.HAVE_METADATA) {
                        try {
                            await new Promise((res, rej) => {
                                const metaTimeout = setTimeout(() => rej(new Error("Timeout waiting for metadata.")), 1000);
                                videoElement.onloadedmetadata = () => { clearTimeout(metaTimeout); res(); };
                                videoElement.onerror = () => { clearTimeout(metaTimeout); rej(new Error("Video error on metadata wait."));};
                            });
                        } catch(e) { return reject("Video not ready for thumbnail (wait failed): " + e.message); }
                    }
                    if (!videoElement || videoElement.readyState < videoElement.HAVE_METADATA || videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                        return reject("Video not ready for thumbnail (no dimensions or metadata).");
                    }
                }
        
                const ar = videoElement.videoWidth / videoElement.videoHeight;
                const canvasWidth = forLog ? 240 : 240; 
                const canvasHeight = canvasWidth / ar;
                if (isNaN(canvasHeight) || !isFinite(canvasHeight) || canvasHeight <= 0) {
                     return reject("Invalid video dimensions for thumbnail.");
                }
        
                const originalTime = videoElement.currentTime;
                const originalPaused = videoElement.paused;
                const originalMuted = videoElement.muted;
                videoElement.muted = true; 
        
                let seekTimeoutId = null;
                let imageBitmap = null; 

                const cleanupAndRestore = (isSuccess = true) => {
                    clearTimeout(seekTimeoutId);
                    videoElement.removeEventListener('seeked', onSeekedHandler);
                    videoElement.removeEventListener('error', onErrorHandler);
                    
                    if (!originalPaused && videoElement.paused && videoElement.readyState >= videoElement.HAVE_METADATA) {
                        videoElement.play().catch(e => console.warn("ThumbGen: Playback resume failed", e));
                    }
                    videoElement.muted = originalMuted;
                    
                    if (videoElement === app.data.videoElement && Math.abs(videoElement.currentTime - originalTime) > 0.1 && isSuccess) {
                       // No automatic jump back for main player (S3) to avoid UI disruption.
                    } else if (videoElement !== app.data.videoElement && videoElement.readyState >= videoElement.HAVE_METADATA) {
                         try { videoElement.currentTime = originalTime; } catch(e){} 
                    }

                    if (imageBitmap && typeof imageBitmap.close === 'function') {
                        try { imageBitmap.close(); } catch(e) { console.warn("ThumbGen: Error closing main thread ImageBitmap", e); }
                    }
                };
        
                const processFrame = async () => {
                    try {
                        await new Promise(r => requestAnimationFrame(r)); 
                        
                        imageBitmap = await createImageBitmap(videoElement, 0, 0, videoElement.videoWidth, videoElement.videoHeight, {
                            resizeWidth: canvasWidth,
                            resizeHeight: canvasHeight,
                            resizeQuality: 'medium'
                        });
        
                        if (this.data.thumbnailWorker) {
                            const blob = await this._postToThumbnailWorker({
                                type: 'fromImageBitmap',
                                imageData: imageBitmap, 
                                canvasWidth: imageBitmap.width,
                                canvasHeight: imageBitmap.height
                            });
                            resolve(blob);
                        } else { 
                            const canvas = this.dom.thumbnailCanvas;
                            canvas.width = imageBitmap.width;
                            canvas.height = imageBitmap.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(imageBitmap, 0, 0);
                            canvas.toBlob(blobRes => {
                                if (blobRes) resolve(blobRes);
                                else reject(new Error("Canvas toBlob failed in fallback."));
                            }, 'image/jpeg', 0.8);
                        }
                    } catch (e) {
                        reject(new Error("Error creating/processing ImageBitmap: " + e.message));
                    } finally {
                         cleanupAndRestore(true); 
                    }
                };

                const onSeekedHandler = () => {
                    clearTimeout(seekTimeoutId);
                    videoElement.removeEventListener('error', onErrorHandler); 
                    if (videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                        processFrame();
                    } else {
                        reject(new Error("Video data unavailable after seek for thumbnail."));
                        cleanupAndRestore(false);
                    }
                };
        
                const onErrorHandler = (e) => {
                    clearTimeout(seekTimeoutId);
                    videoElement.removeEventListener('seeked', onSeekedHandler); 
                    reject(new Error("Video error during seek for thumbnail: " + (videoElement.error?.message || e.type || 'Unknown error')));
                    cleanupAndRestore(false);
                };
        
                videoElement.addEventListener('seeked', onSeekedHandler, { once: true });
                videoElement.addEventListener('error', onErrorHandler, { once: true });
        
                if (!originalPaused) videoElement.pause();
                
                seekTimeoutId = setTimeout(() => {
                    reject(new Error("Seek timeout for thumbnail generation."));
                    cleanupAndRestore(false);
                }, 5000); 
        
                if (Math.abs(videoElement.currentTime - time) < 0.1 && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                    clearTimeout(seekTimeoutId); 
                    videoElement.removeEventListener('seeked', onSeekedHandler); 
                    videoElement.removeEventListener('error', onErrorHandler);
                    processFrame(); 
                } else if (videoElement.readyState < videoElement.HAVE_METADATA && time === 0) {
                     videoElement.currentTime = time;
                }
                else {
                    videoElement.currentTime = time; 
                }
            });
        },
        
        async generateGenericThumbnailFromFile(videoFile) { 
            return new Promise(async (resolve, reject) => {
                const tempVideoEl = document.createElement('video');
                tempVideoEl.muted = true;
                tempVideoEl.preload = 'metadata';
                const objectURL = URL.createObjectURL(videoFile);
                tempVideoEl.src = objectURL;

                let resolved = false; 
                let loadTimeoutId = null;

                const cleanup = () => {
                    URL.revokeObjectURL(objectURL); 
                    tempVideoEl.removeEventListener('loadedmetadata', onLoadedMetadata);
                    tempVideoEl.removeEventListener('error', onError);
                    tempVideoEl.src = ''; 
                    tempVideoEl.load(); 
                    clearTimeout(loadTimeoutId);
                };

                const onLoadedMetadata = async () => {
                    if (resolved) return;
                    resolved = true;
                    clearTimeout(loadTimeoutId);

                    if (tempVideoEl.videoWidth === 0 || tempVideoEl.videoHeight === 0) {
                        cleanup();
                        reject(new Error("Video dimensions not available after metadata load."));
                        return;
                    }
                    
                    const seekTime = Math.min(0.5, (tempVideoEl.duration > 0 ? tempVideoEl.duration * 0.1 : 0.1));
                    try {
                        const blob = await this._generateThumbnailFromVideoElement(tempVideoEl, seekTime, false);
                        cleanup();
                        resolve(blob);
                    } catch (e) {
                        console.error("Error in _generateThumbnailFromVideoElement from generic:", e);
                        cleanup();
                        reject(e);
                    }
                };
        
                const onError = (e) => {
                    if (resolved) return;
                    resolved = true;
                    cleanup();
                    reject(new Error("Error loading video file for thumbnail: " + (tempVideoEl.error?.message || e.type || 'Unknown error')));
                };
        
                tempVideoEl.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
                tempVideoEl.addEventListener('error', onError, { once: true });

                loadTimeoutId = setTimeout(() => {
                    if (!resolved) {
                        resolved = true; 
                        cleanup();
                        reject(new Error("Timeout loading video metadata for generic thumbnail."));
                    }
                }, 7000); 
            });
        },
        
        async generateLogThumbnail(time) { 
            if (!this.data.videoElement || !this.data.videoElement.src || this.data.videoElement.readyState < 2 || !this.dom.videoFilePrompt.classList.contains('hidden') || this.data.videoElement.videoWidth === 0 || this.data.videoElement.videoHeight === 0) {
                return Promise.reject("Video (S3) not ready for log thumbnail.");
            }
            try {
                return await this._generateThumbnailFromVideoElement(this.data.videoElement, time, true);
            } catch (e) {
                console.error("Error generating log thumbnail:", e);
                return Promise.reject(e);
            }
        },

        async confirmDeleteVideo(videoId) { 
            const video = this.getVideoById(this.data.currentProjectId, videoId);
            if (!video) return;
            const message = `Delete "<strong>${this.utils.escapeHtml(video.filename)}</strong>" and all its logs? <br>This also removes it from persistent storage. Cannot be undone.`;
            this.showConfirmationModal(
                message, 
                async () => await this.deleteVideo(videoId), 
                null, 
                { text: 'Delete Video', icon: 'trash', class: 'button-danger' }
            );
        },
        async deleteVideo(videoId) { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project || !project.videos) return;
            const videoIndex = project.videos.findIndex(v => v.id === videoId);
            if (videoIndex === -1) return;

            const videoToDelete = project.videos[videoIndex];
            const currentProjectId = this.data.currentProjectId; 

            try {
                await this.DataManager.deleteVideo(videoId); 

                if (this.data.activeCardPlayer.videoId === videoId) this.resetActiveCardPlayerUI(); 
                this.revokeActiveObjectURL(`video-${videoId}`);
                if (videoToDelete.logs) {
                    videoToDelete.logs.forEach(log => this.revokeActiveObjectURL(`log-${log.id}`));
                }
                const cacheKey = `${currentProjectId}-${videoId}`; 
                if (this.data.videoFileCache[cacheKey]) { URL.revokeObjectURL(this.data.videoFileCache[cacheKey]); delete this.data.videoFileCache[cacheKey]; }
                
                this.utils.removeSessionStorageItem('scrollPos_screen-video-logging-window-' + currentProjectId + '-' + videoId);
                this.utils.removeSessionStorageItem('scrollPos_videoLogsList-' + currentProjectId + '-' + videoId);
                const s2ClipListKey = `s2_clipsList_${currentProjectId}_${videoId}`;
                this.utils.removeSessionStorageItem('scrollPos_' + s2ClipListKey);
                delete this.data.scrollPositions['screen-video-logging-window-' + currentProjectId + '-' + videoId];
                delete this.data.scrollPositions['videoLogsList-' + currentProjectId + '-' + videoId];
                delete this.data.scrollPositions[s2ClipListKey];

                project.videos.splice(videoIndex, 1);
                if (this.data.currentVideoId === videoId) this.data.currentVideoId = null; 
                
                await this.renderProjectVideosScreen();
                this.showToast(`Video "${this.utils.escapeHtml(videoToDelete.filename)}" deleted.`, 'success', 3000, 'check-circle');
            } catch (err) {
                console.error("Error deleting video:", err);
                this.showToast(`Failed to delete video "${this.utils.escapeHtml(videoToDelete.filename)}".`, "error", 5000, 'x-circle');
            }
        },
        async toggleVideoImportance(videoId) { 
            const project = this.getProjectById(this.data.currentProjectId); if (!project) return;
            const video = project.videos.find(v => v.id === videoId); if (!video) return;
            video.isImportant = !video.isImportant; 
            
            const videoToStore = { ...video }; delete videoToStore.logs;

            try {
                await this.DataManager.updateVideo(videoToStore);

                const cardElement = this.dom.projectVideosContainer.querySelector(`article.video-entry-card[data-video-id="${videoId}"]`);
                if (cardElement) {
                    const buttonElement = cardElement.querySelector('.btn-toggle-important');
                    if (buttonElement) {
                        buttonElement.classList.toggle('is-important', video.isImportant);
                        buttonElement.title = video.isImportant ? 'Unmark as important' : 'Mark as important';
                        buttonElement.setAttribute('aria-pressed', video.isImportant.toString());
                        const iconSpan = buttonElement.querySelector('.button-icon');
                        if (iconSpan) {
                            iconSpan.innerHTML = this.getIcon(video.isImportant ? 'star-filled' : 'star-outline');
                        }
                    }
                } else {
                    await this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); 
                }

                this.showToast(`Video marked ${video.isImportant ? 'important' : 'not important'}.`, 'info', 3000, 'info-circle');
            } catch (err) {
                console.error("Error toggling video importance:", err);
                video.isImportant = !video.isImportant; 
                await this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); 
                this.showToast("Failed to update video importance.", "error", 4000, 'x-circle');
            }
        },

        resetActiveCardPlayerUI() { 
            const acp = this.data.activeCardPlayer;
            if (acp.playerElement) {
                acp.playerElement.pause();
                acp.playerElement.removeAttribute('src');
                acp.playerElement.load(); 
                
                if (acp.boundPlayerTimeUpdate) acp.playerElement.removeEventListener('timeupdate', acp.boundPlayerTimeUpdate);
                if (acp.boundPlayerLoadedMetadata) acp.playerElement.removeEventListener('loadedmetadata', acp.boundPlayerLoadedMetadata);
                if (acp.boundPlayerEnded) acp.playerElement.removeEventListener('ended', acp.boundPlayerEnded);
                if (acp.boundPlayerError) acp.playerElement.removeEventListener('error', acp.boundPlayerError);
                if (acp.boundPlayerPlay) acp.playerElement.removeEventListener('play', acp.boundPlayerPlay);
                if (acp.boundPlayerPause) acp.playerElement.removeEventListener('pause', acp.boundPlayerPause);
                if (acp.speedSelectElement && acp.boundSpeedChange) { // ADDED
                    acp.speedSelectElement.removeEventListener('change', acp.boundSpeedChange);
                    acp.speedSelectElement.value = "1"; // Reset to 1x
                }


                acp.playerElement.classList.add('hidden');
                if (acp.controlsContainerElement) { acp.controlsContainerElement.classList.remove('visible'); } 
                if (acp.promptElement) acp.promptElement.classList.add('hidden');
                
                const videoData = acp.videoId ? this.getVideoById(this.data.currentProjectId, acp.videoId) : null;
                let sourceFileAvailable = false;
                if (videoData) {
                   sourceFileAvailable = !!(this.data.videoFileCache[`${this.data.currentProjectId}-${acp.videoId}`] || (async() => await this.idb.retrieveFile(acp.videoId))());
                }


                if (acp.thumbnailElement && sourceFileAvailable) acp.thumbnailElement.classList.remove('hidden'); else if(acp.thumbnailElement) acp.thumbnailElement.classList.add('hidden');
                if (acp.bigPlayButtonElement && sourceFileAvailable) acp.bigPlayButtonElement.classList.remove('hidden'); else if(acp.bigPlayButtonElement) acp.bigPlayButtonElement.classList.add('hidden');


                if (acp.timecodeElement) acp.timecodeElement.textContent = '00:00 / 00:00';
                if (acp.progressBarElement) acp.progressBarElement.style.width = '0%';
                if (acp.playPauseBtnElement) { 
                    const iconSpan = acp.playPauseBtnElement.querySelector('.button-icon');
                    if(iconSpan) iconSpan.innerHTML = this.getIcon('play');
                    acp.playPauseBtnElement.setAttribute('aria-label', 'Play');
                }
                clearTimeout(acp.controlsHideTimer);
            }
            this.data.activeCardPlayer = { 
                videoId: null, cardElement: null, playerElement: null, thumbnailElement: null,
                bigPlayButtonElement: null, promptElement: null, fileInputElement: null,
                controlsContainerElement: null, playPauseBtnElement: null, rewindBtnElement: null,
                forwardBtnElement: null, progressBarContainerElement: null, progressBarElement: null,
                timecodeElement: null, stopBtnElement: null, speedSelectElement: null, // ADDED
                isPlaying: false, isScrubbing: false,
                wasPlayingBeforeScrub: false, currentSegment: { startTime: 0, endTime: 0, duration: 0 },
                boundPlayerTimeUpdate: null, boundPlayerLoadedMetadata: null, boundPlayerEnded: null,
                boundPlayerError: null, boundPlayerPlay: null, boundPlayerPause: null, boundSpeedChange: null, // ADDED
                _boundCardPlayerScrubMove: null, _boundCardPlayerScrubEnd: null,
                controlsHideTimer: null
            };
        },

        async playVideoOnCard(videoId, cardElement, segmentData = null) {
            const videoData = this.getVideoById(this.data.currentProjectId, videoId);
            if (!videoData) {
                this.showToast("Video data not found.", "error");
                return;
            }

            let performFullSetup = false;
            const currentGlobalAcp = this.data.activeCardPlayer;

            if (currentGlobalAcp.videoId !== videoId || 
                !currentGlobalAcp.playerElement || 
                currentGlobalAcp.playerElement !== cardElement.querySelector(`#main-player-${videoId}`)) {
                performFullSetup = true;
            }
            
            if (performFullSetup) {
                this.resetActiveCardPlayerUI(); 
                
                const acp = this.data.activeCardPlayer; 
                acp.videoId = videoId;
                acp.cardElement = cardElement;
                const previewArea = cardElement.querySelector(`#main-preview-area-${videoId}`);
                if (!previewArea) { console.error("Preview area not found for videoId:", videoId); return; }

                acp.playerElement = previewArea.querySelector(`#main-player-${videoId}`);
                acp.thumbnailElement = previewArea.querySelector(`#main-thumbnail-${videoId}`);
                acp.bigPlayButtonElement = previewArea.querySelector(`#play-main-preview-btn-${videoId}`);
                acp.promptElement = previewArea.querySelector(`#main-player-prompt-${videoId}`);
                if(acp.promptElement) acp.fileInputElement = acp.promptElement.querySelector('.main-video-preview-file-input');
                acp.controlsContainerElement = previewArea.querySelector(`#main-player-controls-${videoId}`);
                
                if(acp.controlsContainerElement){
                    acp.playPauseBtnElement = acp.controlsContainerElement.querySelector('.main-player-play-pause-btn');
                    acp.rewindBtnElement = acp.controlsContainerElement.querySelector('.main-player-rewind-btn');
                    acp.forwardBtnElement = acp.controlsContainerElement.querySelector('.main-player-forward-btn');
                    acp.progressBarContainerElement = acp.controlsContainerElement.querySelector('.main-player-progress-bar-container');
                    if(acp.progressBarContainerElement) acp.progressBarElement = acp.progressBarContainerElement.querySelector('.main-player-progress-bar');
                    acp.timecodeElement = acp.controlsContainerElement.querySelector('.main-player-timecode');
                    acp.stopBtnElement = acp.controlsContainerElement.querySelector('.main-player-stop-btn');
                    acp.speedSelectElement = acp.controlsContainerElement.querySelector('.main-player-speed-select'); // ADDED
                }

                if(!acp.playerElement || !acp.thumbnailElement || !acp.bigPlayButtonElement || !acp.promptElement || !acp.controlsContainerElement) {
                    this.showToast("Player UI error on new setup.", "error", 3000, 'x-circle'); return;
                }
                
                acp.boundPlayerError = () => this.handleCardPlayerError(videoData.filename);
                acp.boundPlayerLoadedMetadata = () => this.handleCardPlayerLoadedMetadata(segmentData); 
                acp.boundPlayerTimeUpdate = () => this.handleCardPlayerTimeUpdate();
                acp.boundPlayerEnded = () => this.handleCardPlayerEnded(); 
                acp.boundPlayerPlay = () => { 
                    acp.isPlaying = true; 
                    if(acp.playPauseBtnElement) { 
                        const iconSpan = acp.playPauseBtnElement.querySelector('.button-icon');
                        if(iconSpan) iconSpan.innerHTML = this.getIcon('pause');
                        acp.playPauseBtnElement.setAttribute('aria-label', 'Pause'); 
                    }
                    if(acp.controlsContainerElement) { clearTimeout(acp.controlsHideTimer); acp.controlsContainerElement.classList.add('visible'); }
                };
                acp.boundPlayerPause = () => { 
                    acp.isPlaying = false; 
                    if(acp.playPauseBtnElement && !acp.isScrubbing) {
                        const iconSpan = acp.playPauseBtnElement.querySelector('.button-icon');
                        if(iconSpan) iconSpan.innerHTML = this.getIcon('play');
                        acp.playPauseBtnElement.setAttribute('aria-label', 'Play'); 
                    }
                    if(acp.controlsContainerElement && previewArea && !previewArea.matches(':hover') && !acp.controlsContainerElement.matches(':hover')) { 
                        acp.controlsHideTimer = setTimeout(() => {
                            if(acp.controlsContainerElement) acp.controlsContainerElement.classList.remove('visible');
                        }, 3000);
                    }
                };

                acp.playerElement.addEventListener('error', acp.boundPlayerError);
                acp.playerElement.addEventListener('loadedmetadata', acp.boundPlayerLoadedMetadata);
                acp.playerElement.addEventListener('timeupdate', acp.boundPlayerTimeUpdate);
                acp.playerElement.addEventListener('ended', acp.boundPlayerEnded);
                acp.playerElement.addEventListener('play', acp.boundPlayerPlay);
                acp.playerElement.addEventListener('pause', acp.boundPlayerPause);
                if (acp.speedSelectElement) { // ADDED block
                    acp.boundSpeedChange = () => {
                        if (acp.playerElement && acp.speedSelectElement) {
                            acp.playerElement.playbackRate = parseFloat(acp.speedSelectElement.value);
                        }
                    };
                    acp.speedSelectElement.addEventListener('change', acp.boundSpeedChange);
                }
            }
            const acpForPlayback = this.data.activeCardPlayer; 
            const videoSrc = await this.getVideoSource(this.data.currentProjectId, videoId, videoData.filename);
            
            if (videoSrc) {
                if (acpForPlayback.playerElement.getAttribute('src') !== videoSrc) {
                    acpForPlayback.playerElement.src = videoSrc;
                    acpForPlayback.playerElement.load(); 
                } else { 
                    this.handleCardPlayerLoadedMetadata(segmentData); 
                }
                if (acpForPlayback.playerElement.paused || (segmentData && Math.abs(acpForPlayback.playerElement.currentTime - segmentData.startTime) > 0.1)) {
                    acpForPlayback.playerElement.play().catch(e => {
                        if(e.name === "NotAllowedError") this.showToast("Playback blocked by browser.", "warning", 4000, 'alert-triangle');
                        this.showCardPlayerPrompt(videoData.filename);
                    });
                }
            } else {
                this.showCardPlayerPrompt(videoData.filename);
                return; 
            }

            if (acpForPlayback.thumbnailElement) acpForPlayback.thumbnailElement.classList.add('hidden');
            if (acpForPlayback.bigPlayButtonElement) acpForPlayback.bigPlayButtonElement.classList.add('hidden');
            if (acpForPlayback.playerElement) acpForPlayback.playerElement.classList.remove('hidden');
            if (acpForPlayback.promptElement) acpForPlayback.promptElement.classList.add('hidden');
            if (acpForPlayback.controlsContainerElement) {
                clearTimeout(acpForPlayback.controlsHideTimer);
                acpForPlayback.controlsContainerElement.classList.add('visible');
            }

            if (acpForPlayback.controlsContainerElement && acpForPlayback.cardElement) {
                const controlsRect = acpForPlayback.controlsContainerElement.getBoundingClientRect();
                const cardRect = acpForPlayback.cardElement.getBoundingClientRect();
                if (controlsRect.bottom > window.innerHeight || cardRect.top < 0 ) {
                     acpForPlayback.cardElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        },

        handleCardPlayerLoadedMetadata(segmentData) { 
            const acp = this.data.activeCardPlayer;
            if (!acp.playerElement || !acp.playerElement.duration || isNaN(acp.playerElement.duration)) {
                return; 
            }

            if (segmentData && typeof segmentData.startTime === 'number' && typeof segmentData.endTime === 'number' && segmentData.endTime > segmentData.startTime) { 
                acp.currentSegment.startTime = segmentData.startTime;
                acp.currentSegment.endTime = Math.min(segmentData.endTime, acp.playerElement.duration); 
                acp.currentSegment.duration = acp.currentSegment.endTime - acp.currentSegment.startTime;
                
                if (Math.abs(acp.playerElement.currentTime - acp.currentSegment.startTime) > 0.1) {
                     acp.playerElement.currentTime = acp.currentSegment.startTime;
                }
            } else { 
                acp.currentSegment.startTime = 0;
                acp.currentSegment.endTime = acp.playerElement.duration;
                acp.currentSegment.duration = acp.playerElement.duration;
                if(acp.playerElement.currentTime >= acp.playerElement.duration - 0.1 && acp.playerElement.duration > 0) { 
                    acp.playerElement.currentTime = 0;
                }
            }
            if (acp.playerElement && acp.speedSelectElement) { // ADDED
                acp.playerElement.playbackRate = parseFloat(acp.speedSelectElement.value);
            }
            this.updateCardPlayerTimeDisplay(); 
        },
        handleCardPlayerTimeUpdate() { 
            const acp = this.data.activeCardPlayer;
            if (!acp.playerElement || !acp.playerElement.duration || isNaN(acp.playerElement.duration) || acp.isScrubbing) return;
            const currentTimeAbsolute = acp.playerElement.currentTime;
            if (acp.currentSegment.duration > 0 && currentTimeAbsolute >= acp.currentSegment.endTime - 0.05) { 
                acp.playerElement.pause(); acp.playerElement.currentTime = acp.currentSegment.endTime; this.handleCardPlayerSegmentEnd(); return;
            }
            if (currentTimeAbsolute < acp.currentSegment.startTime) acp.playerElement.currentTime = acp.currentSegment.startTime; 
            const currentTimeInSegment = Math.max(0, currentTimeAbsolute - acp.currentSegment.startTime);
            const progress = (acp.currentSegment.duration > 0) ? (currentTimeInSegment / acp.currentSegment.duration) * 100 : 0;
            if(acp.progressBarElement) acp.progressBarElement.style.width = `${Math.max(0, Math.min(100, progress))}%`;
            this.updateCardPlayerTimeDisplay();
        },
        handleCardPlayerSegmentEnd() { 
            const acp = this.data.activeCardPlayer; acp.isPlaying = false; 
            if(acp.playPauseBtnElement) { 
                const iconSpan = acp.playPauseBtnElement.querySelector('.button-icon');
                if(iconSpan) iconSpan.innerHTML = this.getIcon('play');
                acp.playPauseBtnElement.setAttribute('aria-label', 'Replay'); 
            }
            if(acp.progressBarElement) acp.progressBarElement.style.width = '100%'; this.updateCardPlayerTimeDisplay(); 
        },
        handleCardPlayerEnded() { 
            const acp = this.data.activeCardPlayer; acp.isPlaying = false; 
            if(acp.playPauseBtnElement) { 
                const iconSpan = acp.playPauseBtnElement.querySelector('.button-icon');
                if(iconSpan) iconSpan.innerHTML = this.getIcon('play');
                acp.playPauseBtnElement.setAttribute('aria-label', 'Replay'); 
            }
            if(acp.progressBarElement) acp.progressBarElement.style.width = '100%';
            if(acp.playerElement) acp.playerElement.currentTime = acp.currentSegment.endTime; this.updateCardPlayerTimeDisplay();
        },
        handleCardPlayerError(filename) { 
            this.showToast(`Error playing video/clip from "${this.utils.escapeHtml(filename)}".`, 'error', 5000, 'x-circle');
            this.showCardPlayerPrompt(filename);
            const acp = this.data.activeCardPlayer;
            if (!acp || !acp.videoId) return; 
            const cacheKey = `${this.data.currentProjectId}-${acp.videoId}`;
            if(this.data.videoFileCache[cacheKey]) { URL.revokeObjectURL(this.data.videoFileCache[cacheKey]); delete this.data.videoFileCache[cacheKey]; }
            this.idb.deleteFile(acp.videoId).catch(err => console.warn("Could not delete problematic source file from IDB:", err));
        },
        updateCardPlayerTimeDisplay() { 
            const acp = this.data.activeCardPlayer;
            if (!acp.playerElement || !acp.timecodeElement || isNaN(acp.currentSegment.duration)) {
                if(acp.timecodeElement) acp.timecodeElement.textContent = '00:00 / 00:00'; return;
            }
            const currentTimeInSegment = Math.max(0, Math.min(acp.playerElement.currentTime - acp.currentSegment.startTime, acp.currentSegment.duration));
            const displayDuration = acp.currentSegment.duration > 0 ? acp.currentSegment.duration : 0;
            acp.timecodeElement.textContent = `${this.utils.formatTime(currentTimeInSegment)} / ${this.utils.formatTime(displayDuration)}`;
        },
        toggleCardPlayerPlayPause() { 
            const acp = this.data.activeCardPlayer;
            if (!acp.playerElement || !acp.playerElement.src) {
                const videoData = acp.videoId ? this.getVideoById(this.data.currentProjectId, acp.videoId) : null;
                if(videoData) this.showCardPlayerPrompt(videoData.filename);
                else this.showToast("Video not loaded.", "warning", 3000, 'alert-triangle'); 
                return;
            }
            if (acp.isPlaying) { acp.playerElement.pause(); } 
            else {
                if (acp.playerElement.currentTime >= acp.currentSegment.endTime - 0.1) { acp.playerElement.currentTime = acp.currentSegment.startTime; }
                acp.playerElement.play().catch(e => {
                    if(e.name === "NotAllowedError") this.showToast("Playback blocked.", "warning", 3000, 'alert-triangle');
                });
            }
        },
        rewindCardPlayer() { 
            const acp = this.data.activeCardPlayer; if (!acp.playerElement || !acp.playerElement.src) return;
            acp.playerElement.currentTime = Math.max(acp.currentSegment.startTime, acp.playerElement.currentTime - this.data.skipTimeSeconds);
        },
        forwardCardPlayer() { 
            const acp = this.data.activeCardPlayer; if (!acp.playerElement || !acp.playerElement.src) return;
            acp.playerElement.currentTime = Math.min(acp.currentSegment.endTime, acp.playerElement.currentTime + this.data.skipTimeSeconds);
        },
        stopAndResetCardPlayer() { this.resetActiveCardPlayerUI(); },
        handleCardPlayerProgressBarMouseDown(event) { 
            const acp = this.data.activeCardPlayer; if (!acp.playerElement || !acp.playerElement.src || isNaN(acp.currentSegment.duration) || acp.currentSegment.duration <=0 ) return;
            event.preventDefault(); acp.isScrubbing = true; acp.wasPlayingBeforeScrub = acp.isPlaying; 
            if (acp.isPlaying) acp.playerElement.pause(); this.updateCardPlayerProgressBarOnScrub(event);
            acp._boundCardPlayerScrubMove = this.updateCardPlayerProgressBarOnScrub.bind(this);
            acp._boundCardPlayerScrubEnd = (e) => { document.removeEventListener('mousemove', acp._boundCardPlayerScrubMove); document.removeEventListener('mouseup', acp._boundCardPlayerScrubEnd); acp.isScrubbing = false; if (acp.wasPlayingBeforeScrub && acp.playerElement) acp.playerElement.play().catch(()=>{}); this.updateCardPlayerTimeDisplay(); };
            document.addEventListener('mousemove', acp._boundCardPlayerScrubMove); document.addEventListener('mouseup', acp._boundCardPlayerScrubEnd);
        },
        handleCardPlayerProgressBarTouchStart(event) { 
            const acp = this.data.activeCardPlayer; if (!acp.playerElement || !acp.playerElement.src || isNaN(acp.currentSegment.duration) || acp.currentSegment.duration <=0 ) return;
            acp.isScrubbing = true; acp.wasPlayingBeforeScrub = acp.isPlaying; if (acp.isPlaying) acp.playerElement.pause();
            this.updateCardPlayerProgressBarOnScrub(event.touches[0] || event.changedTouches[0]); 
            acp._boundCardPlayerScrubMove = (e) => { e.preventDefault(); this.updateCardPlayerProgressBarOnScrub(e.touches[0] || e.changedTouches[0]); }
            acp._boundCardPlayerScrubEnd = (e) => { document.removeEventListener('touchmove', acp._boundCardPlayerScrubMove); document.removeEventListener('touchend', acp._boundCardPlayerScrubEnd); document.removeEventListener('touchcancel', acp._boundCardPlayerScrubEnd); acp.isScrubbing = false; if (acp.wasPlayingBeforeScrub && acp.playerElement) acp.playerElement.play().catch(()=>{}); this.updateCardPlayerTimeDisplay(); };
            document.addEventListener('touchmove', acp._boundCardPlayerScrubMove, { passive: false }); document.addEventListener('touchend', acp._boundCardPlayerScrubEnd); document.addEventListener('touchcancel', acp._boundCardPlayerScrubEnd);
        },
        updateCardPlayerProgressBarOnScrub(event) { 
            const acp = this.data.activeCardPlayer; if (!acp.progressBarContainerElement || !acp.playerElement || acp.currentSegment.duration <= 0) return;
            const rect = acp.progressBarContainerElement.getBoundingClientRect(); const clientX = event.clientX; 
            const clickX = clientX - rect.left; const seekRatio = Math.max(0, Math.min(1, clickX / rect.width));
            const newTimeInSegment = seekRatio * acp.currentSegment.duration; acp.playerElement.currentTime = acp.currentSegment.startTime + newTimeInSegment;
            if(acp.progressBarElement) acp.progressBarElement.style.width = `${seekRatio * 100}%`; this.updateCardPlayerTimeDisplay();
        },
        showCardPlayerPrompt(videoFilename) { 
            const acp = this.data.activeCardPlayer;
            if (acp.promptElement) { 
                const promptMsgElement = acp.promptElement.querySelector('p');
                if(promptMsgElement) promptMsgElement.innerHTML = `Video "<strong>${this.utils.escapeHtml(videoFilename)}</strong>" needs to be selected.`;
                acp.promptElement.classList.remove('hidden');
                if (acp.playerElement) acp.playerElement.classList.add('hidden');
                if (acp.controlsContainerElement) acp.controlsContainerElement.classList.remove('visible'); 
                if (acp.thumbnailElement) acp.thumbnailElement.classList.add('hidden'); 
                if (acp.bigPlayButtonElement) acp.bigPlayButtonElement.classList.add('hidden');
            }
        },
        async handleCardPlayerFileSelection(file, videoIdToMatch) { 
            let acp = this.data.activeCardPlayer; 
            if (!acp.videoId || acp.videoId !== videoIdToMatch) {
                const cardElement = document.querySelector(`.video-entry-card[data-video-id="${videoIdToMatch}"]`);
                if (cardElement) {
                    this.resetActiveCardPlayerUI(); 
                    acp = this.data.activeCardPlayer; 
                    acp.videoId = videoIdToMatch;
                    acp.cardElement = cardElement;
                    const previewArea = cardElement.querySelector(`#main-preview-area-${videoIdToMatch}`);
                    if (!previewArea) { this.showToast("Player UI error.", "error", 3000, 'x-circle'); return; }
                    acp.playerElement = previewArea.querySelector(`#main-player-${videoIdToMatch}`);
                    acp.promptElement = previewArea.querySelector(`#main-player-prompt-${videoIdToMatch}`);
                    acp.controlsContainerElement = previewArea.querySelector(`#main-player-controls-${videoIdToMatch}`);
                    if(acp.promptElement) acp.fileInputElement = acp.promptElement.querySelector('.main-video-preview-file-input');
                    if(acp.controlsContainerElement) {
                        acp.speedSelectElement = acp.controlsContainerElement.querySelector('.main-player-speed-select');
                        acp.playPauseBtnElement = acp.controlsContainerElement.querySelector('.main-player-play-pause-btn'); // Ensure this is cached
                    }
                    const videoDataForEvents = this.getVideoById(this.data.currentProjectId, acp.videoId);
                    if (videoDataForEvents && acp.playerElement) {
                        acp.boundPlayerError = () => this.handleCardPlayerError(videoDataForEvents.filename);
                        acp.boundPlayerLoadedMetadata = () => this.handleCardPlayerLoadedMetadata(null); 
                        acp.boundPlayerTimeUpdate = () => this.handleCardPlayerTimeUpdate();
                        acp.boundPlayerEnded = () => this.handleCardPlayerEnded();
                        acp.boundPlayerPlay = () => { acp.isPlaying = true; if(acp.playPauseBtnElement){const i=acp.playPauseBtnElement.querySelector('.button-icon');if(i)i.innerHTML=this.getIcon('pause');acp.playPauseBtnElement.setAttribute('aria-label','Pause');} if(acp.controlsContainerElement){clearTimeout(acp.controlsHideTimer);acp.controlsContainerElement.classList.add('visible');}};
                        acp.boundPlayerPause = () => { acp.isPlaying = false; if(acp.playPauseBtnElement&&!acp.isScrubbing){const i=acp.playPauseBtnElement.querySelector('.button-icon');if(i)i.innerHTML=this.getIcon('play');acp.playPauseBtnElement.setAttribute('aria-label','Play');} const pa=acp.cardElement ? acp.cardElement.querySelector(`#main-preview-area-${acp.videoId}`) : null;if(acp.controlsContainerElement&&pa&&!pa.matches(':hover')&&!acp.controlsContainerElement.matches(':hover')){acp.controlsHideTimer=setTimeout(()=>{if(acp.controlsContainerElement)acp.controlsContainerElement.classList.remove('visible');},3000);}};
                        if (acp.speedSelectElement) { 
                            acp.boundSpeedChange = () => {
                                if (acp.playerElement && acp.speedSelectElement) {
                                    acp.playerElement.playbackRate = parseFloat(acp.speedSelectElement.value);
                                }
                            };
                            acp.speedSelectElement.addEventListener('change', acp.boundSpeedChange);
                        }
                        acp.playerElement.addEventListener('error', acp.boundPlayerError);
                        acp.playerElement.addEventListener('loadedmetadata', acp.boundPlayerLoadedMetadata);
                        acp.playerElement.addEventListener('timeupdate', acp.boundPlayerTimeUpdate);
                        acp.playerElement.addEventListener('ended', acp.boundPlayerEnded);
                        acp.playerElement.addEventListener('play', acp.boundPlayerPlay);
                        acp.playerElement.addEventListener('pause', acp.boundPlayerPause);
                    } else {
                        console.error("Could not fully setup player context after file selection prompt.");
                    }

                } else {
                    this.showToast("Associated card not found.", "error", 3000, 'x-circle'); return;
                }
            }

            if (!file) { this.showToast("No file selected.", "warning", 3000, 'alert-triangle'); if(acp.fileInputElement) acp.fileInputElement.value = ''; return; }
            
            const videoData = this.getVideoById(this.data.currentProjectId, acp.videoId); 
            if (!videoData) { this.showToast("Video data not found.", "error", 3000, 'x-circle'); if(acp.fileInputElement) acp.fileInputElement.value = ''; return; }
            
            if (file.name !== videoData.filename) {
                this.showToast(`Incorrect file. Expected "${this.utils.escapeHtml(videoData.filename)}".`, "warning", 3000, 'alert-triangle');
                if(acp.fileInputElement) acp.fileInputElement.value = ''; return;
            }
            const cacheKey = `${this.data.currentProjectId}-${acp.videoId}`;
            if (this.data.videoFileCache[cacheKey]) URL.revokeObjectURL(this.data.videoFileCache[cacheKey]);
            try { await this.idb.storeFile(acp.videoId, file); this.showToast(`"${this.utils.escapeHtml(file.name)}" saved for faster access.`, 'info', 4000, 'info-circle'); } 
            catch { this.showToast(`Could not save "${this.utils.escapeHtml(file.name)}" persistently.`, 'warning', 3000, 'alert-triangle'); }
            
            const objectURL = URL.createObjectURL(file); this.data.videoFileCache[cacheKey] = objectURL; 

            // Check if thumbnail needs regeneration
             if (videoData && (!videoData.mainVideoThumbnail || 
                             (!(videoData.mainVideoThumbnail instanceof Blob) && 
                              !(typeof videoData.mainVideoThumbnail === 'string' && videoData.mainVideoThumbnail.startsWith('data:image')))
                            )
            ) {
                this.showToast(`Generating preview thumbnail for "${this.utils.escapeHtml(file.name)}"...`, 'info', 4000, 'spinner');
                try {
                    const newThumbnailBlob = await this.generateGenericThumbnailFromFile(file);
                    if (newThumbnailBlob) {
                        videoData.mainVideoThumbnail = newThumbnailBlob; // Update in-memory app.data

                        const videoToStore = { 
                            id: videoData.id,
                            projectId: videoData.projectId,
                            filename: videoData.filename,
                            createdAt: videoData.createdAt,
                            isImportant: videoData.isImportant,
                            mainVideoThumbnail: newThumbnailBlob 
                        };
                        await this.DataManager.updateVideo(videoToStore);
                        this.showToast(`Thumbnail updated for "${this.utils.escapeHtml(file.name)}".`, 'success', 2500, 'check-circle');
                        
                        // Critical: Reset active player if it's the current one to force re-setup for thumbnail change
                        if (this.data.activeCardPlayer.videoId === videoIdToMatch) {
                            this.resetActiveCardPlayerUI();
                        }
                        await this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); // Re-render to show new thumbnail

                    } else {
                        this.showToast(`Could not generate thumbnail for "${this.utils.escapeHtml(file.name)}".`, 'warning', 3000, 'alert-triangle');
                    }
                } catch (err) {
                    console.error("Error regenerating thumbnail on import file selection:", err);
                    this.showToast("Error generating thumbnail during import.", "error", 4000, 'x-circle');
                }
            }


            if (acp.playerElement && acp.promptElement && acp.controlsContainerElement) {
                acp.promptElement.classList.add('hidden'); acp.playerElement.classList.remove('hidden'); 
                acp.controlsContainerElement.classList.add('visible'); 
                acp.playerElement.src = objectURL; acp.playerElement.load(); 
                acp.playerElement.play().catch(e => { if(e.name === "NotAllowedError") this.showToast("Playback blocked.", "warning", 3000, 'alert-triangle'); });
            } else { this.showToast("Player UI elements missing after file selection.", "error", 3000, 'x-circle'); }
            
            if(acp.fileInputElement) acp.fileInputElement.value = '';
        },
        async confirmDeleteLogItemFromScreen2(videoId, logId){ 
            const log = this.getLogById(this.data.currentProjectId, videoId, logId); if (!log) return;
            const message = `Delete this log entry? <br><small style="color:var(--text-color-light);">${this.utils.escapeHtml(log.notes.substring(0,50))}...</small><br>Cannot be undone.`;
            this.showConfirmationModal(
                message, 
                async () => await this.deleteLogItem(videoId, logId), 
                null, 
                { text: 'Delete Log', icon: 'trash', class: 'button-danger' }
            );
        },
        async deleteLogItem(videoId, logId) { 
            const video = this.getVideoById(this.data.currentProjectId, videoId); if (!video || !video.logs) return;
            const logToDelete = video.logs.find(l => l.id === logId); 
            
            try {
                await this.DataManager.deleteLog(logId);
                this.revokeActiveObjectURL(`log-${logId}`); 

                if (this.data.activeCardPlayer.videoId === videoId && logToDelete && this.data.activeCardPlayer.currentSegment &&
                    logToDelete.markIn === this.data.activeCardPlayer.currentSegment.startTime && logToDelete.markOut === this.data.activeCardPlayer.currentSegment.endTime ) {
                    this.resetActiveCardPlayerUI(); 
                }
                video.logs = video.logs.filter(l => l.id !== logId); 
                await this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); 
                if(logToDelete) this.showToast(`Log entry deleted.`, 'success', 3000, 'check-circle');
            } catch (err) {
                 console.error("Error deleting log item:", err);
                this.showToast("Failed to delete log entry.", "error", 4000, 'x-circle');
            }
        },


        async renderVideoLoggingScreen() { 
            const videoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!videoData) { this.navigateTo('screen-project-videos', { projectId: this.data.currentProjectId }); this.showToast("Video not found.", "error", 3000, 'x-circle'); return; }
            this.dom.videoFilenameHeader.textContent = this.utils.escapeHtml(videoData.filename);
            this.resetLogForm(); 
            await this.renderSavedLogsList(); 
            
            this.data.videoElement.pause(); 
            this.data.videoElement.removeAttribute('src'); this.data.videoElement.load(); 
            
            const playPauseIconSpan = this.data.playPauseBtn.querySelector('.button-icon');
            if (playPauseIconSpan) playPauseIconSpan.innerHTML = this.getIcon('play');
            this.data.playPauseBtn.setAttribute('aria-label', 'Play video');

            this.updateVideoTimes(); this.dom.videoPlayerContainer.classList.remove('hidden'); 
            this.dom.videoFilePrompt.classList.add('hidden'); this.data.videoElement.classList.add('hidden'); 
            this.data.videoElement.removeAttribute('controls');
            const videoSrc = await this.getVideoSource(this.data.currentProjectId, this.data.currentVideoId, videoData.filename);
            if (videoSrc) {
                this.data.videoElement.src = videoSrc; this.data.videoElement.classList.remove('hidden'); this.dom.videoFilePrompt.classList.add('hidden'); 
            } else { this.promptForVideoFile(videoData.filename); }
        },
        promptForVideoFile(filename) { 
            this.data.videoElement.classList.add('hidden'); this.dom.videoFilePrompt.classList.remove('hidden'); 
            this.dom.videoFilePromptMessage.innerHTML = `Video "<strong>${this.utils.escapeHtml(filename)}</strong>" needs to be selected.`;
            this.dom.videoFileInputLogging.dataset.expectedFilename = filename; 
        },
        async handleVideoFileSelectionForLogging(file) { 
            const expectedFilename = this.dom.videoFileInputLogging.dataset.expectedFilename;
            const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if(!currentVideoData) { this.showToast("Video context lost.", "error", 3000, 'x-circle'); this.dom.videoFileInputLogging.value = ''; return; }
            if (file && file.name === expectedFilename) {
                const cacheKey = `${this.data.currentProjectId}-${this.data.currentVideoId}`;
                if (this.data.videoFileCache[cacheKey]) URL.revokeObjectURL(this.data.videoFileCache[cacheKey]);
                try { await this.idb.storeFile(this.data.currentVideoId, file); this.showToast(`"${this.utils.escapeHtml(file.name)}" saved for faster access.`, 'info', 4000, 'info-circle'); } 
                catch { this.showToast(`Could not save "${this.utils.escapeHtml(file.name)}" persistently.`, 'warning', 3000, 'alert-triangle'); }
                const objectURL = URL.createObjectURL(file); this.data.videoFileCache[cacheKey] = objectURL; 
                this.data.videoElement.src = objectURL; this.dom.videoFilePrompt.classList.add('hidden'); this.data.videoElement.classList.remove('hidden'); 
            } else if (file) { this.showToast(`Incorrect file. Expected "${expectedFilename}".`, 'warning', 3000, 'alert-triangle'); }
            this.dom.videoFileInputLogging.value = ''; 
        },
        updateVideoTimes() { 
            if (!this.data.videoElement || !this.data.videoElement.duration || isNaN(this.data.videoElement.duration)) {
                this.data.timecodeDisplay.textContent = '00:00 / 00:00'; this.data.timelineProgress.style.width = '0%';
                if(this.data.markInBtn) this.data.markInBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-in')}</span> Mark In (00:00.0)`;
                if(this.data.markOutBtn) this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (00:00.0)`; return;
            }
            const currentTime = this.data.videoElement.currentTime; const duration = this.data.videoElement.duration;
            this.data.timecodeDisplay.textContent = `${this.utils.formatTime(currentTime)} / ${this.utils.formatTime(duration)}`;
            if (!this.data.isScrubbing) this.data.timelineProgress.style.width = `${(currentTime / duration) * 100}%`;
            
            if (this.data.markInTime === 0 || (this.data.markInBtn && this.data.markInBtn.classList.contains('default-mark'))) {
                this.data.markInBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-in')}</span> Mark In (${this.utils.formatTime(currentTime, true)})`;
            }
            if (this.data.markOutTime === null || (this.data.markOutBtn && this.data.markOutBtn.classList.contains('default-mark'))) {
                this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (${this.utils.formatTime(currentTime, true)})`;
            }
        },
        async togglePlayPause() { 
            if (!this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden')) { 
                const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                this.showToast("Please select a video file.", "warning", 3000, 'alert-triangle'); 
                this.promptForVideoFile(currentVideoData?.filename || "the video file"); return; 
            }
            if (this.data.videoElement.paused || this.data.videoElement.ended) { 
                try { await this.data.videoElement.play(); } catch (e) {
                     this.showToast("Error playing video.", "error", 3000, 'x-circle');
                     const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                     if (currentVideoData) this.promptForVideoFile(currentVideoData.filename);
                }
            } else { this.data.videoElement.pause(); }
        },
        rewindVideo() { if (!this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden') || isNaN(this.data.videoElement.duration)) { this.showToast("Video not ready.", "warning", 3000, 'alert-triangle'); return; } this.data.videoElement.currentTime = Math.max(0, this.data.videoElement.currentTime - this.data.skipTimeSeconds); },
        fastForwardVideo() { if (!this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden') || isNaN(this.data.videoElement.duration)) { this.showToast("Video not ready.", "warning", 3000, 'alert-triangle'); return; } this.data.videoElement.currentTime = Math.min(this.data.videoElement.duration, this.data.videoElement.currentTime + this.data.skipTimeSeconds); },
        
        handleTimelineMouseDown(event) { if (!this.data.videoElement || !this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden') || isNaN(this.data.videoElement.duration)) { this.showToast("Video not ready.", "warning", 3000, 'alert-triangle'); return; } event.preventDefault(); this.data.isScrubbing = true; this.data.wasPlayingBeforeScrub = !this.data.videoElement.paused; if (this.data.wasPlayingBeforeScrub) this.data.videoElement.pause(); this.updateTimelineOnScrub(event); document.addEventListener('mousemove', this.boundHandleTimelineMouseMove); document.addEventListener('mouseup', this.boundHandleTimelineMouseUp); },
        handleTimelineMouseMove(event) { if (!this.data.isScrubbing) return; this.updateTimelineOnScrub(event); },
        handleTimelineMouseUp(event) { if (!this.data.isScrubbing) return; this.data.isScrubbing = false; this.updateTimelineOnScrub(event); document.removeEventListener('mousemove', this.boundHandleTimelineMouseMove); document.removeEventListener('mouseup', this.boundHandleTimelineMouseUp); if (this.data.wasPlayingBeforeScrub) this.data.videoElement.play().catch(()=>{}); this.updateVideoTimes(); },
        handleTimelineTouchStart(event) { if (!this.data.videoElement || !this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden') || isNaN(this.data.videoElement.duration)) { this.showToast("Video not ready.", "warning", 3000, 'alert-triangle'); return; } this.data.isScrubbing = true; this.data.wasPlayingBeforeScrub = !this.data.videoElement.paused; if (this.data.wasPlayingBeforeScrub) this.data.videoElement.pause(); this.updateTimelineOnScrub(event.touches[0]); document.addEventListener('touchmove', this.boundHandleTimelineTouchMove, { passive: false }); document.addEventListener('touchend', this.boundHandleTimelineTouchEnd); document.addEventListener('touchcancel', this.boundHandleTimelineTouchEnd); },
        handleTimelineTouchMove(event) { if (!this.data.isScrubbing) return; event.preventDefault(); this.updateTimelineOnScrub(event.touches[0]); },
        handleTimelineTouchEnd(event) { if (!this.data.isScrubbing) return; this.data.isScrubbing = false; if (event.changedTouches && event.changedTouches.length > 0) this.updateTimelineOnScrub(event.changedTouches[0]); document.removeEventListener('touchmove', this.boundHandleTimelineTouchMove); document.removeEventListener('touchend', this.boundHandleTimelineTouchEnd); document.removeEventListener('touchcancel', this.boundHandleTimelineTouchEnd); if (this.data.wasPlayingBeforeScrub) this.data.videoElement.play().catch(()=>{}); this.updateVideoTimes(); },
        updateTimelineOnScrub(event) {
            if (!this.data.videoElement || !this.data.videoElement.duration || isNaN(this.data.videoElement.duration)) return; 
            const timelineRect = this.data.timelineContainer.getBoundingClientRect(); let clientX = event.clientX;
            const clickX = clientX - timelineRect.left; const seekRatio = Math.max(0, Math.min(1, clickX / timelineRect.width));
            const newTime = seekRatio * this.data.videoElement.duration; this.data.videoElement.currentTime = newTime;
            this.data.timelineProgress.style.width = `${seekRatio * 100}%`; this.data.timecodeDisplay.textContent = `${this.utils.formatTime(newTime)} / ${this.utils.formatTime(this.data.videoElement.duration)}`;
        },

        setMarkIn() { 
            if (!this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden')) { this.showToast("Load video first.", "warning", 3000, 'alert-triangle'); return; }
            this.data.markInTime = this.data.videoElement.currentTime;
            this.data.markInBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-in')}</span> Mark In (${this.utils.formatTime(this.data.markInTime, true)})`;
            this.data.markInBtn.classList.remove('default-mark'); 
            this.data.markInBtn.classList.add('active-mark'); 
            setTimeout(() => { this.data.markInBtn.classList.remove('active-mark');}, 1000);
            if (this.data.markOutTime !== null && this.data.markOutTime < this.data.markInTime) {
                this.data.markOutTime = null; 
                this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (${this.utils.formatTime(this.data.videoElement.currentTime, true)})`;
                this.data.markOutBtn.classList.add('default-mark');
            }
        },
        setMarkOut() { 
            if (!this.data.videoElement.src || !this.dom.videoFilePrompt.classList.contains('hidden')) { this.showToast("Load video first.", "warning", 3000, 'alert-triangle'); return; }
            const currentTime = this.data.videoElement.currentTime;
            if (currentTime <= this.data.markInTime) { this.showToast("Mark Out must be after Mark In.", "warning", 3000, 'alert-triangle'); return; }
            this.data.markOutTime = currentTime;
            this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (${this.utils.formatTime(this.data.markOutTime, true)})`;
            this.data.markOutBtn.classList.remove('default-mark'); 
            this.data.markOutBtn.classList.add('active-mark');
            setTimeout(() => { this.data.markOutBtn.classList.remove('active-mark'); }, 1000);
        },
        handleStarRating(event) { 
            const starButton = event.target.closest('button.star');
            if (starButton) { this.data.currentRating = parseInt(starButton.dataset.value); this.updateStarDisplay(); }
        },
        updateStarDisplay() { 
            this.dom.logRatingContainer.querySelectorAll('button.star').forEach(star => {
                const selected = parseInt(star.dataset.value) <= this.data.currentRating;
                star.innerHTML = this.getIcon(selected ? 'star-filled' : 'star-outline');
                star.classList.toggle('selected', selected);
                star.setAttribute('aria-pressed', selected ? 'true' : 'false');
            });
        },
        async saveLogEntry() { 
            const notes = this.dom.logNotes.value.trim();
            const keywords = [...this.data.logKeywordsData]; 

            if (this.data.markOutTime === null || this.data.markOutTime <= this.data.markInTime) { this.showToast("Set valid Mark In/Out times.", "warning", 3000, 'alert-triangle'); return; }
            if (!notes) { this.showToast("Notes cannot be empty.", "warning", 3000, 'alert-triangle'); return; }
            if (this.data.currentRating === 0) { this.showToast("Please provide a rating.", "warning", 3000, 'alert-triangle'); return; }
            
            this.setButtonLoadingState(this.dom.saveLogBtn, true, 'Saving...');

            let thumbnailBlob = null;
            try {
                if (this.data.videoElement.src && this.data.videoElement.readyState >= 2 && this.dom.videoFilePrompt.classList.contains('hidden')) { 
                    thumbnailBlob = await this.generateLogThumbnail(this.data.markInTime); 
                    if (!thumbnailBlob) console.warn("Log thumbnail is null/undefined after generation for time:", this.data.markInTime);
                } 
            } catch (error) { 
                this.showToast("Could not generate thumbnail for log.", "warning", 3000, 'alert-triangle');
                console.error("CRITICAL: Log thumbnail generation error:", error);
            }
            
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!video) { this.showToast("Error: Video not found.", "error", 3000, 'x-circle'); this.setButtonLoadingState(this.dom.saveLogBtn, false); return; }
            
            const editingLogId = this.dom.editingLogIdInput.value;
            let logDataForDB = { 
                markIn: this.data.markInTime, 
                markOut: this.data.markOutTime, 
                notes: notes, 
                rating: this.data.currentRating, 
                keywords: keywords, 
                thumbnail: thumbnailBlob, 
                videoId: this.data.currentVideoId,
                projectId: this.data.currentProjectId
            };
            
            try {
                if (editingLogId) { 
                    const existingLog = video.logs.find(l => l.id === editingLogId);
                    if (existingLog) {
                        logDataForDB.id = editingLogId;
                        logDataForDB.createdAt = existingLog.createdAt; 
                        logDataForDB.updatedAt = new Date().toISOString();
                        await this.DataManager.updateLog(logDataForDB);
                        Object.assign(existingLog, logDataForDB);
                    }
                    this.showToast("Log entry updated.", "success", 3000, 'check-circle');
                } else { 
                    logDataForDB.id = this.utils.generateId();
                    logDataForDB.createdAt = new Date().toISOString();
                    await this.DataManager.addLog(logDataForDB);
                    if (!video.logs) video.logs = [];
                    video.logs.push(logDataForDB); 
                    this.showToast("Log entry saved.", "success", 3000, 'check-circle');
                }
                await this.renderSavedLogsList(); this.resetLogForm();
            } catch(err) {
                console.error("Error saving log entry:", err);
                this.showToast("Failed to save log entry.", "error", 5000, 'x-circle');
            } finally {
                this.setButtonLoadingState(this.dom.saveLogBtn, false);
            }
        },
        
        resetLogForm() { 
            this.dom.logNotes.value = ''; 
            this.data.logKeywordsData = []; 
            this.renderKeywordTags(); 
            this.data.currentRating = 0; this.updateStarDisplay();
            this.data.markInTime = 0; this.data.markOutTime = null;
            const defaultTime = (this.data.videoElement && this.data.videoElement.src && this.dom.videoFilePrompt.classList.contains('hidden')) ? this.data.videoElement.currentTime : 0;
            this.data.markInBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-in')}</span> Mark In (${this.utils.formatTime(defaultTime, true)})`; this.data.markInBtn.classList.add('default-mark');
            this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (${this.utils.formatTime(defaultTime, true)})`; this.data.markOutBtn.classList.add('default-mark');
            this.dom.editingLogIdInput.value = ''; 
            
            this.dom.saveLogBtn.innerHTML = `<span class="button-icon">${this.getIcon('save')}</span> Save Log`; 
            this.dom.saveLogBtn.disabled = false; 

            if (this.dom.btnCancelEditLog) {
                this.dom.btnCancelEditLog.classList.add('hidden');
            }
        },
        _createOrUpdateLogItem(log, existingItem = null) {
            const logItemId = `log-item-${log.id}`;
            const logThumbId = `log-${log.id}`;
            this.revokeActiveObjectURL(logThumbId); 

            let logThumbSrc = '';
            if (log.thumbnail instanceof Blob) {
                logThumbSrc = URL.createObjectURL(log.thumbnail);
                this.data.activeObjectURLs[logThumbId] = logThumbSrc;
            } else if (typeof log.thumbnail === 'string' && log.thumbnail.startsWith('data:image')) {
                logThumbSrc = log.thumbnail; 
            }

            const ratingStars = Array(5).fill(0).map((_, i) => this.getIcon(i < log.rating ? 'star-filled' : 'star-outline', `star-icon ${i < log.rating ? 'filled' : 'empty'}`)).join('');
            const keywordsDisplay = (log.keywords && Array.isArray(log.keywords) && log.keywords.length > 0) 
                                    ? log.keywords.map(k => `<span>${this.utils.escapeHtml(k)}</span>`).join('') 
                                    : '';
            const thumbnailHTML = logThumbSrc ? `<img src="${logThumbSrc}" alt="Log thumbnail">` : '';

            if (existingItem) { 
                existingItem.querySelector('.log-item-time').textContent = `${this.utils.formatTime(log.markIn)} - ${this.utils.formatTime(log.markOut)}`;
                existingItem.querySelector('.log-item-rating-display').innerHTML = ratingStars;
                existingItem.querySelector('.log-item-notes').textContent = this.utils.escapeHtml(log.notes);
                const keywordsDiv = existingItem.querySelector('.log-item-keywords');
                if (keywordsDisplay) {
                    if (keywordsDiv) keywordsDiv.innerHTML = keywordsDisplay;
                    else { 
                        const newKeywordsDiv = document.createElement('div');
                        newKeywordsDiv.className = 'log-item-keywords';
                        newKeywordsDiv.innerHTML = keywordsDisplay;
                        existingItem.querySelector('.log-item-notes').insertAdjacentElement('afterend', newKeywordsDiv);
                    }
                } else if (keywordsDiv) {
                    keywordsDiv.remove();
                }
                const imgEl = existingItem.querySelector('img');
                if (thumbnailHTML) {
                    if (imgEl) imgEl.src = logThumbSrc;
                    else { 
                        const tempDiv = document.createElement('div'); tempDiv.innerHTML = thumbnailHTML;
                        existingItem.querySelector('.card-actions').insertAdjacentElement('beforebegin', tempDiv.firstChild);
                    }
                } else if (imgEl) {
                    imgEl.remove();
                }
                return existingItem;
            } else { 
                const item = document.createElement('article'); 
                item.className = 'log-item'; 
                item.id = logItemId;
                item.dataset.logId = log.id; 
                item.innerHTML = `
                    <div class="log-item-header">
                        <span class="log-item-time">${this.utils.formatTime(log.markIn)} - ${this.utils.formatTime(log.markOut)}</span>
                        <div class="log-item-rating-display">${ratingStars}</div>
                    </div>
                    <p class="log-item-notes">${this.utils.escapeHtml(log.notes)}</p>
                    ${keywordsDisplay ? `<div class="log-item-keywords">${keywordsDisplay}</div>` : ''}
                    ${thumbnailHTML}
                    <div class="card-actions" style="margin-top:10px;">
                        <button class="button button-subtle button-small btn-go-to-log-time" data-time="${log.markIn}" aria-label="Go to time"><span class="button-icon">${this.getIcon('play-circle')}</span> Go to</button>
                        <button class="button button-secondary button-small btn-edit-log" data-log-id="${log.id}" aria-label="Edit log"><span class="button-icon">${this.getIcon('pencil')}</span> Edit</button>
                        <button class="button button-subtle button-small btn-delete-log" data-log-id="${log.id}" aria-label="Delete log"><span class="button-icon">${this.getIcon('trash')}</span> Delete</button>
                    </div>
                `;
                return item;
            }
        },

        async renderSavedLogsList() { 
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            const logsContainer = this.dom.savedLogsList;
            
            let previousScrollTop = 0;
            if (logsContainer) {
                previousScrollTop = logsContainer.scrollTop;
            }

            const existingLogItems = new Map();
            if (logsContainer) {
                logsContainer.querySelectorAll('article.log-item[data-log-id]').forEach(item => {
                    existingLogItems.set(item.dataset.logId, item);
                });
            }

            if (!video || !video.logs || video.logs.length === 0) {
                if (logsContainer) {
                    existingLogItems.forEach((item, logId) => {
                        this.revokeActiveObjectURL(`log-${logId}`);
                        item.remove();
                    });
                    logsContainer.innerHTML = `
                        <div class="empty-state" style="padding:20px; font-size:0.9em;">
                            <div class="empty-state-icon">${this.getIcon('document-text')}</div>
                            <p>No logs saved for this video yet.</p>
                        </div>`;
                }
                if (logsContainer) {
                    requestAnimationFrame(() => { logsContainer.scrollTop = previousScrollTop; });
                }
                return;
            }
            
            const fragment = document.createDocumentFragment();
            const sortedLogs = [...video.logs].sort((a, b) => a.markIn - b.markIn);

            for (const log of sortedLogs) {
                const existingItem = existingLogItems.get(log.id);
                const logElement = this._createOrUpdateLogItem(log, existingItem);
                fragment.appendChild(logElement);
                if (existingItem) {
                    existingLogItems.delete(log.id); 
                }
            }
            
            if (logsContainer) {
                existingLogItems.forEach((item, logId) => {
                    this.revokeActiveObjectURL(`log-${logId}`);
                    item.remove();
                });

                logsContainer.innerHTML = ''; 
                logsContainer.appendChild(fragment); 

                logsContainer.querySelectorAll('.btn-go-to-log-time').forEach(btn => btn.addEventListener('click', (e) => this.goToLogTime(parseFloat(e.currentTarget.dataset.time))));
                logsContainer.querySelectorAll('.btn-edit-log').forEach(btn => btn.addEventListener('click', (e) => this.editLogEntry(e.currentTarget.dataset.logId)));
                logsContainer.querySelectorAll('.btn-delete-log').forEach(btn => btn.addEventListener('click', (e) => this.confirmDeleteLogOnScreen3(e.currentTarget.dataset.logId)));

                requestAnimationFrame(() => { logsContainer.scrollTop = previousScrollTop; });
            }
        },
        async goToLogTime(time) { 
            if(this.data.videoElement && this.data.videoElement.src && this.dom.videoFilePrompt.classList.contains('hidden')) {
                this.data.videoElement.currentTime = time; 
                try { await this.data.videoElement.play(); } catch(e) { this.showToast("Error playing video.", "error", 3000, 'x-circle'); }
                this.data.videoElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else { 
                const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                this.showToast("Video file not loaded.", "warning", 3000, 'alert-triangle'); 
                this.promptForVideoFile(currentVideoData?.filename || "the video file"); 
            }
        },
        async editLogEntry(logId, fromNavigation = false) { 
            const videoIdForLog = this.data.currentVideoId; 
            const log = this.getLogById(this.data.currentProjectId, videoIdForLog, logId);
            if (!log) return;
            this.dom.logNotes.value = log.notes;
            
            if (log.keywords) {
                if (Array.isArray(log.keywords)) {
                    this.data.logKeywordsData = [...log.keywords];
                } else if (typeof log.keywords === 'string' && log.keywords.length > 0) {
                    this.data.logKeywordsData = log.keywords.split(',')
                                                        .map(k => k.trim())
                                                        .filter(k => k);
                } else { this.data.logKeywordsData = []; }
            } else { this.data.logKeywordsData = []; }
            this.renderKeywordTags(); 

            this.data.currentRating = log.rating; this.updateStarDisplay();
            this.data.markInTime = log.markIn; this.data.markOutTime = log.markOut;
            if (this.data.videoElement && this.data.videoElement.src && this.dom.videoFilePrompt.classList.contains('hidden')) { this.data.videoElement.currentTime = log.markIn; 
            }
            this.data.markInBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-in')}</span> Mark In (${this.utils.formatTime(log.markIn, true)})`;
            this.data.markOutBtn.innerHTML = `<span class="button-icon">${this.getIcon('mark-out')}</span> Mark Out (${this.utils.formatTime(log.markOut, true)})`;
            this.data.markInBtn.classList.remove('default-mark'); this.data.markOutBtn.classList.remove('default-mark');
            this.dom.editingLogIdInput.value = log.id; 
            
            this.dom.saveLogBtn.innerHTML = `<span class="button-icon">${this.getIcon('save')}</span> Update Log`;
            
            if (this.dom.btnCancelEditLog) {
                this.dom.btnCancelEditLog.classList.remove('hidden');
            }

            this.dom.logNotes.focus();
            const logFormCard = this.dom.logNotes.closest('article.card');
            if (logFormCard) logFormCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        },
        async confirmDeleteLogOnScreen3(logId) { 
             const log = this.getLogById(this.data.currentProjectId, this.data.currentVideoId, logId); if (!log) return;
            const message = `Delete this log entry? <br><small style="color:var(--text-color-light);">${this.utils.escapeHtml(log.notes.substring(0,50))}...</small><br>Cannot be undone.`;
            this.showConfirmationModal(
                message, 
                async () => await this.deleteLogOnScreen3(logId), 
                null, 
                { text: 'Delete Log', icon: 'trash', class: 'button-danger' }
            );
        },
          async deleteLogOnScreen3(logId) { 
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!video || !video.logs) return;
            
            try {
                await this.DataManager.deleteLog(logId);
                this.revokeActiveObjectURL(`log-${logId}`); 

                video.logs = video.logs.filter(l => l.id !== logId); 
                if(this.dom.editingLogIdInput.value === logId) { this.resetLogForm(); }
                await this.renderSavedLogsList(); 
                this.showToast("Log entry deleted.", 'success', 3000, 'check-circle');
            } catch (err) {
                console.error("Error deleting log on S3:", err);
                this.showToast("Failed to delete log entry.", "error", 4000, 'x-circle');
            }
        },

        renderKeywordTags() {
            const inputField = this.dom.logKeywordsInputField;
            const existingTags = this.dom.logKeywordsContainer.querySelectorAll('.tag-item');
            existingTags.forEach(tag => tag.remove());
            
            this.data.logKeywordsData.forEach(keyword => {
                const tagEl = document.createElement('span');
                tagEl.className = 'tag-item';
                tagEl.textContent = this.utils.escapeHtml(keyword);
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'remove-tag-btn';
                removeBtn.setAttribute('aria-label', `Remove keyword ${this.utils.escapeHtml(keyword)}`);
                removeBtn.innerHTML = this.getIcon('x-sm');
                tagEl.appendChild(removeBtn);
                this.dom.logKeywordsContainer.insertBefore(tagEl, inputField); 
            });
            this.dom.logKeywordsHidden.value = this.data.logKeywordsData.join(','); 
        },
        addKeywordTag(keyword) {
            keyword = keyword.trim().toLowerCase(); 
            if (keyword && !this.data.logKeywordsData.includes(keyword)) {
                this.data.logKeywordsData.push(keyword);
                this.renderKeywordTags();
            }
        },
        removeKeywordTag(keyword) {
            this.data.logKeywordsData = this.data.logKeywordsData.filter(k => k !== keyword);
            this.renderKeywordTags();
        },
        handleKeywordInputKeydown(event) {
            if (event.key === 'Enter' || event.key === ',') {
                event.preventDefault();
                const keyword = this.dom.logKeywordsInputField.value.trim();
                this.addKeywordTag(keyword);
                this.dom.logKeywordsInputField.value = '';
            } else if (event.key === 'Backspace' && this.dom.logKeywordsInputField.value === '' && this.data.logKeywordsData.length > 0) {
                this.removeKeywordTag(this.data.logKeywordsData[this.data.logKeywordsData.length - 1]);
            }
        },
        handleKeywordInputPaste(event) {
            event.preventDefault();
            const pasteData = (event.clipboardData || window.clipboardData).getData('text');
            const keywords = pasteData.split(/,|\n/).map(k => k.trim()).filter(k => k);
                        keywords.forEach(k => this.addKeywordTag(k));
        },
        
        showModal(modalId) { 
            const modal = document.getElementById(modalId); 
            if (modal) {
                this.data.previouslyFocusedElement = document.activeElement;
                modal.style.display = 'block';
                requestAnimationFrame(() => modal.classList.add('visible')); 
                const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                if (firstFocusable) firstFocusable.focus();
            }
        },
        hideModal(modalId) { 
            const modal = document.getElementById(modalId); 
            if (modal) {
                modal.classList.remove('visible');
                const transitionHandler = () => {
                    if (!modal.classList.contains('visible')) {
                        modal.style.display = 'none';
                    }
                    modal.removeEventListener('transitionend', transitionHandler);
                };
                modal.addEventListener('transitionend', transitionHandler);
                setTimeout(() => { 
                    if (!modal.classList.contains('visible')) modal.style.display = 'none'; 
                }, 300); 
            } 
            if (this.data.previouslyFocusedElement) {
                try { this.data.previouslyFocusedElement.focus(); } catch (e) {}
                this.data.previouslyFocusedElement = null;
            }
        },
        showToast(message, type = 'info', duration = 3000, iconName = '') {
            if (!this.dom.toastContainer) { this.dom.toastContainer = document.getElementById('toast-container'); if (!this.dom.toastContainer) return; }
            const toast = document.createElement('div');
            toast.className = `toast-message ${type}`;
            
            let iconSvg = '';
            if (iconName) iconSvg = this.getIcon(iconName);
            else if (type === 'success') iconSvg = this.getIcon('check-circle');
            else if (type === 'error') iconSvg = this.getIcon('x-circle');
            else if (type === 'warning') iconSvg = this.getIcon('alert-triangle');
            else if (type === 'info') iconSvg = this.getIcon('info-circle');
            
            toast.innerHTML = `${iconSvg}<span>${this.utils.escapeHtml(message)}</span>`; 
            toast.setAttribute('role', 'alert');
            this.dom.toastContainer.appendChild(toast);
            requestAnimationFrame(() => { toast.classList.add('show'); });
            setTimeout(() => {
                toast.classList.remove('show');
                const transitionEndHandler = () => {
                    if (toast.parentNode === this.dom.toastContainer) {
                        this.dom.toastContainer.removeChild(toast);
                    }
                    toast.removeEventListener('transitionend', transitionEndHandler);
                };
                toast.addEventListener('transitionend', transitionEndHandler);
                setTimeout(() => {
                     if (toast.parentNode === this.dom.toastContainer && !toast.classList.contains('show')) {
                        this.dom.toastContainer.removeChild(toast);
                    }
                }, 500); 
            }, duration);
        },
        showConfirmationModal(message, onConfirm, onCancel = null, confirmButtonDetails = {}, title = 'Confirm Action') {
            this.dom.modals.confirmAction.querySelector('.modal-title').textContent = title;
            this.dom.confirmActionMessage.innerHTML = message; 

            const btnText = confirmButtonDetails.text || 'Confirm';
            const btnIconName = confirmButtonDetails.icon || null;
            const btnClass = confirmButtonDetails.class || 'button-danger';

            let confirmHTML = '';
            if (btnIconName) {
                confirmHTML += `<span class="button-icon">${this.getIcon(btnIconName)}</span> `;
            }
            confirmHTML += this.utils.escapeHtml(btnText);

            this.dom.btnConfirmActionConfirm.innerHTML = confirmHTML;
            this.dom.btnConfirmActionConfirm.className = `button ${btnClass}`;

            this.dom.btnConfirmActionConfirm.onclick = () => { onConfirm(); this.hideModal('modal-confirm-action'); };
            this.dom.btnConfirmActionCancel.onclick = () => { if (onCancel) onCancel(); this.hideModal('modal-confirm-action'); };
            this.showModal('modal-confirm-action');
        },
        setButtonLoadingState(buttonElement, isLoading, loadingText = 'Loading...') {
            if (!buttonElement) return;
            
            if (isLoading) {
                buttonElement.disabled = true;
                // Only store originalContent if it's not already a loading state and not the cancel button
                if (!buttonElement.dataset.originalContent && 
                    !buttonElement.querySelector('.animate-spin') &&
                    buttonElement.id !== 'btn-cancel-edit-log') { 
                     buttonElement.dataset.originalContent = buttonElement.innerHTML;
                }
                const textSpan = loadingText ? `<span>${this.utils.escapeHtml(loadingText)}</span>` : '';
                buttonElement.innerHTML = `<span class="button-icon">${this.getIcon('spinner')}</span>${textSpan}`;
            } else {
                buttonElement.disabled = false;
                // Special handling for save-log-btn: if editingLogId is now empty, force "Save Log" text
                if (buttonElement.id === 'save-log-btn' && this.dom.editingLogIdInput && !this.dom.editingLogIdInput.value) {
                    buttonElement.innerHTML = `<span class="button-icon">${this.getIcon('save')}</span> <span>Save Log</span>`;
                    if(buttonElement.dataset.originalContent) delete buttonElement.dataset.originalContent;
                } else if (buttonElement.dataset.originalContent) {
                    buttonElement.innerHTML = buttonElement.dataset.originalContent;
                    delete buttonElement.dataset.originalContent; 
                } else {
                    // Fallback logic if originalContent was somehow not set
                    let defaultIcon = 'plus';
                    let defaultText = 'Action'; 
                    
                    if(buttonElement.id === 'save-log-btn') { 
                        defaultIcon = 'save'; 
                        defaultText = (this.dom.editingLogIdInput && this.dom.editingLogIdInput.value) ? "Update Log" : "Save Log"; 
                    } else if (buttonElement.id === 'btn-create-project-confirm') { 
                        defaultIcon = 'plus-circle'; 
                        defaultText = "Create Project"; 
                    } else if (buttonElement.id === 'btn-rename-project-confirm') {
                        defaultIcon = 'save';
                        defaultText = "Save Changes";
                    } else if (buttonElement.classList.contains('add-videos-button-label')) {
                        defaultIcon = 'plus';
                        const textSpanElement = buttonElement.querySelector('span:not(.button-icon)');
                        if (textSpanElement && textSpanElement.id === 'add-videos-top-text') {
                            defaultText = "Add Videos";
                        } else if (textSpanElement && textSpanElement.id === 'add-videos-bottom-text') {
                            defaultText = "Add More Videos";
                        } else {
                            defaultText = "Add Videos"; 
                        }
                    }
                    
                    buttonElement.innerHTML = `<span class="button-icon">${this.getIcon(defaultIcon)}</span> <span>${this.utils.escapeHtml(defaultText)}</span>`;
                }
            }
        },

    }; // End of app object

    document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
